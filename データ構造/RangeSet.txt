//ref https://mugen1337.github.io/procon/DataStructure/RangeSet.hpp
/*
verify
insert(l,r),printSet https://atcoder.jp/contests/adt_all_20250520_1/submissions/66027406
getRangeLength, insert(l,r) https://yukicoder.me/submissions/1087100
mex,insert(x) erase(x) https://atcoder.jp/contests/abc330/submissions/66027280
insertの増加量 https://atcoder.jp/contests/abc435/submissions/71558761
*/
template<class T>
struct RangeSet{
  set<pair<T,T>> se;
  T TINF;

  RangeSet(T tinf):TINF{tinf}{ //TINFの値を定義する
    se.emplace(-TINF,-TINF);
    se.emplace(TINF,TINF);
  }
  //増加量を返す
  T insert(T l,T r){
    assert(l<=r);
    auto ite=prev(se.lower_bound({l+1,l+1}));
    if(ite->first<=l and r<=ite->second) return T(0);
    T sum_erased=T(0);
    if(ite->first<=l and l<=ite->second+1){
        l=ite->first;
        sum_erased+=ite->second-ite->first+1;
        ite=se.erase(ite);
    }else ite=next(ite);
    while(r>ite->second){
        sum_erased+=ite->second-ite->first+1;
        ite=se.erase(ite);
    }
    if(ite->first-1<=r and r<=ite->second){
        sum_erased+=ite->second-ite->first+1;
        r=ite->second;
        se.erase(ite);
    }
    se.emplace(l,r);
    return r-l+1-sum_erased;
  }

  T insert(T x){
    return insert(x,x+1);
  }

  bool count(T x){
    auto it = prev(se.lower_bound({x+1,x+1}));
    return (it->first <= x && x < it->second);
  }

  //減少量(正の値)を返す
  T erase(T l,T r){ 
    assert(l<r);
    auto ite=prev(se.lower_bound({l+1,l+1}));
    if(ite->first<=l and r<=ite->second){
      // 完全に1つの区間に包含されている
      if(ite->first<l)  se.emplace(ite->first,l);
      if(r<ite->second) se.emplace(r,ite->second);
      se.erase(ite);
      return r-l;
    }

    T ret=T(0);
    if(ite->first<=l and l<=ite->second){
      ret += ite->second -l;
      if(ite->first<l) se.emplace(ite->first,l);
      ite=se.erase(ite);// 次へ
    }else ite=next(ite);

    while(ite->second<=r){
      ret += ite->second - ite->first;
      ite=se.erase(ite);
    }
    // 右端が区間の間にあるか
    if(ite->first<=r and r<ite->second){
      ret += r-ite->first;
      se.emplace(r,ite->second);
      se.erase(ite);
    }
    return ret;
  }

  T erase(T x){
    return erase(x,x+1);
  }
  // number of range
  int size(){
    return (int)se.size()-2;
  }
  T getRangeLength(T x){
    auto it = prev(se.lower_bound({x+1,x+1}));
    if(it->first <= x && x < it->second){
      return it->second - it->first;
    }else{
      return T{0};
    }
  }
  vector<pair<T,T>> printSet(){
    vector<pair<T,T>>ret;
    for(const auto&[l,r]:se){
      if(l == -TINF || l == TINF)continue;
      ret.emplace_back(l,r);
    }
    return ret;
  }

  T mex(T x = 0){
    auto [nowf,nows] = *prev(se.lower_bound({x+1,x+1}));
    if(nowf <=x  && x < nows){
      return nows;
    }else{
      return x;
    }
  }
};