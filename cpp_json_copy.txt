{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	"atcoder-template": {
		"prefix": "atcoder",
		"body": [
"#include <bits/stdc++.h>",
"#include <atcoder/all>",
"using namespace std;",
"using namespace atcoder;",
"typedef long long ll;",
"typedef unsigned long long ull;",
"typedef long double ld;",
"#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)",
"#define rrep(i,start,end) for (ll i = start;i >= (ll)(end);i--)",
"#define repn(i,end) for(ll i = 0; i <= (ll)(end); i++)",
"#define reps(i,start,end) for(ll i = start; i < (ll)(end); i++)",
"#define repsn(i,start,end) for(ll i = start; i <= (ll)(end); i++)",
"#define each(p,a) for(auto &p:a)",
"typedef vector<ll> vll;",
"typedef vector<pair<ll ,ll>> vpll;",
"typedef vector<vector<ll>> vvll;",
"typedef set<ll> sll;",
"typedef map<ll , ll> mpll;",
"typedef pair<ll ,ll> pll;",
"typedef tuple<ll , ll , ll> tpl3;",
"#define LL(...) ll __VA_ARGS__; input(__VA_ARGS__)",
"#define LD(...) ld __VA_ARGS__; input(__VA_ARGS__)",
"#define Str(...) string __VA_ARGS__; input(__VA_ARGS__)",
"#define Ch(...) char __VA_ARGS__; input(__VA_ARGS__)",
"#define all(a)  (a).begin(),(a).end()",
"#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );",
"#define sz(x) (ll)x.size()",
"// << std::fixed << std::setprecision(10)",
"const ll INF = 1LL << 60;",
"const ld EPS = 1e-9;",
" ",
"ll lceil(ll a,ll b){if(a%b==0){return a/b;}if(a>=0){return (a/b)+1;}else{return -((-a)/b);}}",
"ll lfloor(ll a,ll b){if(a%b==0){return a/b;}if(a>=0){return (a/b);}else{return -((-a)/b)-1;}}",
"inline ll positive_mod(ll a,ll m){return (a % m + m)%m;}",
"inline ll popcnt(ull a){ return __builtin_popcountll(a);}",
"//0indexed",
"inline ll topbit(ll a){assert(a != 0);return 63 - __builtin_clzll(a);}",
"inline ll smlbit(ll a){assert(a != 0);return __builtin_ctzll(a);}",
"template<class T> bool chmin(T& a, T b){if(a > b){a = b;return true;}return false;}",
"template<class T> bool chmax(T& a, T b){if(a < b){a = b;return true;}return false;}",
"template<typename T> std::istream &operator>>(std::istream&is,std::vector<T>&v){for(T &in:v){is>>in;}return is;}",
"template<typename T> std::ostream &operator<<(std::ostream&os,const std::vector<T>&v){for(auto it=std::begin(v);it!=std::end(v);){os<<*it<<((++it)!=std::end(v)?\" \":\"\");}return os;}",
"template<typename T1, typename T2>std::ostream &operator<< (std::ostream &os, std::pair<T1,T2> p){os << \"{\" << p.first << \",\" << p.second << \"}\";return os;}",
"template<class... T>void input(T&... a){(cin >> ... >> a);}",
"void print(){cout << endl;}",
"template<class T, class... Ts>void print(const T& a, const Ts&... b){cout << a;((cout << ' ' << b), ...);cout << endl;}",
"template<class T> void pspace(const T& a){ cout << a << ' ';}",
"void perr(){cerr << endl;}",
"template<class T, class... Ts>void perr(const T& a, const Ts&... b){cerr << a;((cerr << ' ' << b), ...);cerr << endl;}",
"void yes(bool i = true){ return print(i?\"yes\":\"no\"); }",
"void Yes(bool i = true){ return print(i?\"Yes\":\"No\"); }",
"void YES(bool i = true){ return print(i?\"YES\":\"NO\"); }",
"template <class T> vector<T> &operator++(vector<T> &v) {for(auto &e : v) e++;return v;}",
"template <class T> vector<T> operator++(vector<T> &v, signed) {auto res = v;for(auto &e : v) e++;return res;}",
"template <class T> vector<T> &operator--(vector<T> &v) {for(auto &e : v) e--;return v;}",
"template <class T> vector<T> operator--(vector<T> &v, signed) {auto res = v;for(auto &e : v) e--;return res;}",
"//grid探索用",
"vector<ll> _ta = {0,0,1,-1,1,1,-1,-1};",
"vector<ll> _yo = {1,-1,0,0,1,-1,1,-1};",
"bool isin(ll now_i,ll now_j,ll h,ll w){return (0<=now_i && now_i < h && 0 <= now_j && now_j < w);}",
"  ",
"ll lpow(ll x,ll n){ll ans = 1;while(n >0){if(n & 1)ans *= x;x *= x;n >>= 1;}return ans;}",
"ll Modlpow(ll x,ll n,ll m){ll ans = 1;ll a = x%m;while(n >0){if(n & 1){ans *= a;ans%= m;}a *= a;a %= m;n >>= 1;}return ans;} ",
"const ll MOD9 = 998244353LL;",
"const ll MOD10 = 1000000007LL;",

			" ",
			"int main(){",
			"  ios::sync_with_stdio(false);cin.tie(nullptr);",
			"  ",
			"}"
			// "console.log('$1');",
			// "$2"
		],
		"description": "template for AtCoder"
	},
	"codeforces-template": {
		"prefix": "codeforces",
		"body": [
"#include <bits/stdc++.h>",
"using namespace std;",
"typedef long long ll;",
"typedef unsigned long long ull;",
"typedef long double ld;",
"#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)",
"#define rrep(i,start,end) for (ll i = start;i >= (ll)(end);i--)",
"#define repn(i,end) for(ll i = 0; i <= (ll)(end); i++)",
"#define reps(i,start,end) for(ll i = start; i < (ll)(end); i++)",
"#define repsn(i,start,end) for(ll i = start; i <= (ll)(end); i++)",
"#define each(p,a) for(auto &p:a)",
"typedef vector<ll> vll;",
"typedef vector<pair<ll ,ll>> vpll;",
"typedef vector<vector<ll>> vvll;",
"typedef set<ll> sll;",
"typedef map<ll , ll> mpll;",
"typedef pair<ll ,ll> pll;",
"typedef tuple<ll , ll , ll> tpl3;",
"#define LL(...) ll __VA_ARGS__; input(__VA_ARGS__)",
"#define LD(...) ld __VA_ARGS__; input(__VA_ARGS__)",
"#define Str(...) string __VA_ARGS__; input(__VA_ARGS__)",
"#define Ch(...) char __VA_ARGS__; input(__VA_ARGS__)",
"#define all(a)  (a).begin(),(a).end()",
"#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );",
"#define sz(x) (ll)x.size()",
"// << std::fixed << std::setprecision(10)",
"const ll INF = 1LL << 60;",
"const ld EPS = 1e-9;",
" ",
"ll lceil(ll a,ll b){if(a%b==0){return a/b;}if(a>=0){return (a/b)+1;}else{return -((-a)/b);}}",
"ll lfloor(ll a,ll b){if(a%b==0){return a/b;}if(a>=0){return (a/b);}else{return -((-a)/b)-1;}}",
"inline ll positive_mod(ll a,ll m){return (a % m + m)%m;}",
"inline ll popcnt(ull a){ return __builtin_popcountll(a);}",
"//0indexed",
"inline ll topbit(ll a){assert(a != 0);return 63 - __builtin_clzll(a);}",
"inline ll smlbit(ll a){assert(a != 0);return __builtin_ctzll(a);}",
"template<class T> bool chmin(T& a, T b){if(a > b){a = b;return true;}return false;}",
"template<class T> bool chmax(T& a, T b){if(a < b){a = b;return true;}return false;}",
"template<typename T> std::istream &operator>>(std::istream&is,std::vector<T>&v){for(T &in:v){is>>in;}return is;}",
"template<typename T> std::ostream &operator<<(std::ostream&os,const std::vector<T>&v){for(auto it=std::begin(v);it!=std::end(v);){os<<*it<<((++it)!=std::end(v)?\" \":\"\");}return os;}",
"template<typename T1, typename T2>std::ostream &operator<< (std::ostream &os, std::pair<T1,T2> p){os << \"{\" << p.first << \",\" << p.second << \"}\";return os;}",
"template<class... T>void input(T&... a){(cin >> ... >> a);}",
"void print(){cout << endl;}",
"template<class T, class... Ts>void print(const T& a, const Ts&... b){cout << a;((cout << ' ' << b), ...);cout << endl;}",
"template<class T> void pspace(const T& a){ cout << a << ' ';}",
"void perr(){cerr << endl;}",
"template<class T, class... Ts>void perr(const T& a, const Ts&... b){cerr << a;((cerr << ' ' << b), ...);cerr << endl;}",
"void yes(bool i = true){ return print(i?\"yes\":\"no\"); }",
"void Yes(bool i = true){ return print(i?\"Yes\":\"No\"); }",
"void YES(bool i = true){ return print(i?\"YES\":\"NO\"); }",
"template <class T> vector<T> &operator++(vector<T> &v) {for(auto &e : v) e++;return v;}",
"template <class T> vector<T> operator++(vector<T> &v, signed) {auto res = v;for(auto &e : v) e++;return res;}",
"template <class T> vector<T> &operator--(vector<T> &v) {for(auto &e : v) e--;return v;}",
"template <class T> vector<T> operator--(vector<T> &v, signed) {auto res = v;for(auto &e : v) e--;return res;}",
"//grid探索用",
"vector<ll> _ta = {0,0,1,-1,1,1,-1,-1};",
"vector<ll> _yo = {1,-1,0,0,1,-1,1,-1};",
"bool isin(ll now_i,ll now_j,ll h,ll w){return (0<=now_i && now_i < h && 0 <= now_j && now_j < w);}",
"  ",
"ll lpow(ll x,ll n){ll ans = 1;while(n >0){if(n & 1)ans *= x;x *= x;n >>= 1;}return ans;}",
"ll Modlpow(ll x,ll n,ll m){ll ans = 1;ll a = x%m;while(n >0){if(n & 1){ans *= a;ans%= m;}a *= a;a %= m;n >>= 1;}return ans;} ",
"const ll MOD9 = 998244353LL;",
"const ll MOD10 = 1000000007LL;",
			" ",
			"int main(){",
			"  ios::sync_with_stdio(false);cin.tie(nullptr);",
			"  ",
			"}"
			// "console.log('$1');",
			// "$2"
		],
		"description": "template for CodeForces"
	},
	"cout-endl;" : {
		"prefix": "cou",
		"body": [
			"cout << $1 << endl;"
		],
		"description": "template for standard output"
	},
	"cout-space;" : {
		"prefix": "cou2",
		"body": [
			"cout << $1 << \" \" ;"
		],
		"description": "template for standard output with space without endl"
	},
	"binary_search" : {
		"prefix": "Nibunntannsaku",
		"body": [
			"ll ng = $1;//条件を満たさない値",
			"ll ok = $2;//条件を満たす値",
			"auto f = [](ll mid)->bool{",
			" ",
			"};",
			"while(abs(ok-ng) > 1){",
			"  ll mid = (ok + ng)/2;",
			"  if(f(mid)){",
			"    ok = mid;",
			"  }else{",
			"    ng = mid;",
			"  }",
			"}"

		],
		"description": "template for Binary search"
	},
	"素因数分解" : {
		"prefix": "Soinnsuubunnkai_enumpr",
		"body": [
			"//素因数分解",
			"map<ll,ll> enumpr(ll n) {",
			" map<ll,ll> V;",
			" for(ll i=2;i*i<=n;i++) {",
			"    while(n%i==0){",
			"      V[i]++;",
			"      n/=i;",
			"    } ",
			"  }",
			" if(n>1) V[n]++;",
			" return V;",
			"}"
		],
		"description": "template for 素因数分解"
	},
	"約数列挙" : {
		"prefix": "Yakusuurekkyo",
		"body": [
			"//約数列挙",
			"vector<ll> divisor(ll n){",
			"  vector<ll> ret;",
			"  for(ll i = 1;i * i <= n;i++){",
			"    if(n % i == 0){",
			"      ret.push_back(i);",
			"      if(i * i != n)ret.push_back(n/i);",
			"    }",
			"  }",
			"  //昇順",
			"  sort(all(ret));",
			"  return ret;",
			"}"
		],
		"description": "template for 約数列挙"
	},
	"多倍長整数" : {
		"prefix": "Tabaityouseisuu",
		"body": [
			"#include <boost/multiprecision/cpp_int.hpp> ",
			"namespace bmp = boost::multiprecision;",
			"using Bint = bmp::cpp_int;"
		],
		"description": "template for 多倍長整数"
	},
	"時間計測" : {
		"prefix": "Jikannkeisoku",
		"body": [
			"std::chrono::system_clock::time_point  start, end; // 型は auto で可",
			"  start = std::chrono::system_clock::now(); // 計測開始時間",
			"  // 処理",
			"  end = std::chrono::system_clock::now();  // 計測終了時間",
			"  double elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(end-start).count(); //処理に要した時間をミリ秒に変換"
		],
		"description": "template for 時間計測"
	},
	"MaximumFlow" : {
		"prefix": "MaximumFlow",
		"body": [
      "struct Edge {",
      " ll to,cap,rev;",
      "};",
      "",
      "class MaximumFlow{",
      "  public:",
      "  ll siz = 0;",
      "  vector<bool> used;",
      "  vector<vector<Edge>> G;",
      "  MaximumFlow(ll n){",
      "    siz = n;",
      "    used.resize(n+1);",
      "    G.resize(n+1);",
      "  }",
      "",
      "  // a からbにcリットル流せる辺を追加",
      "  void add_edge(ll a,ll b , ll c){",
      "    ll ga_size = G[a].size();",
      "    ll gb_size = G[b].size();",
      "    G[a].push_back({b,c,gb_size });",
      "    G[b].push_back({a,0,ga_size });",
      "  }",
      "",
      "  //Fはスタートからposまでの残余グラフの辺の容量の最小値",
      "  //返り値は流したフローの量",
      "  ll dfs(ll pos,ll goal,ll F){",
      "    // ゴールに到着",
      "    if(pos == goal) return F;",
      "    used[pos] = true;",
      "    for(ll i = 0; i < (ll)G[pos].size();i++){",
      "      // 容量0の辺は使えない",
      "      if(G[pos][i].cap == 0)continue;",
      "      //探索済みだった",
      "      if(used[G[pos][i].to] ==  true) continue;",
      "",
      "      ll flow = dfs(G[pos][i].to,goal,min(F,G[pos][i].cap));",
      "",
      "      // フローを流せるとき、残余グラフの容量をflowだけ増減",
      "      if(flow > 0){",
      "        G[pos][i].cap -= flow;",
      "        G[G[pos][i].to][G[pos][i].rev].cap += flow;",
      "        return flow;",
      "      }",
      "    }",
      "    // 見つからず",
      "    return 0;",
      "  }",
      "",
      "  ll max_flow(ll s,ll t){",
      "    ll Total_Flow = 0;",
      "    while(true){",
      "      for(ll i = 0;i < siz;i++)used[i] = false;",
      "      ll F = dfs(s,t,INF);",
      "",
      "      //流せなくなった",
      "      if(F== 0)break;",
      "      Total_Flow += F;",
      "    }",
      "    return Total_Flow;",
      "  }",
      "};",
		],
		"description": "template for Flow algorism"
	},
	"DFS" : {
		"prefix": "DFS",
		"body": [
			"vector<ll> found(n,0);//n頂点",
			"auto dfs = [&](auto dfs, ll v)->void{",
			"  found[v] = 1;",
			"  //gでグラフを受け取っている",
			"  for(auto &p:g[v]){",
			"    if(found[p] == 0){",
			"      dfs(dfs,p);",
			"    }",
			"  }",
			"};"
		],
		"description": "template for DFS"
	},
	"Warshall_floyd" : {
		"prefix": "WarshallFloyd",
		"body": [
			"/*隣接行列を更新してくDPのイメージ",
			"つながってない辺は重みINF、繋がってたら辺の重みで初期化",
			"O(V^3)",
			"*/",
			"int warshall_floyd(vector<vector<ll>> &dist){",
			"  int size = (int)dist.size();",
			"  rep(k,size){",
			"    rep(i,size){",
			"      rep(j,size){",
			"        if(i == j){",
			"          chmin(dist[i][j],0LL);",
			"        }",
			"        if(dist[i][k] != INF && dist[k][j] != INF){",
			"          chmin(dist[i][j],dist[i][k] + dist[k][j]);",
			"        }",
			"      }",
			"    }",
			"  }",
			"  //負の閉路判定あれば−1大丈夫なら1",
			"  rep(i,size){",
			"    if(dist[i][i]<0){",
			"      return -1;",
			"    }",
			"  }",
			"  return 1;",
			"}"
		],
		"description": "template for WarshallFloyd"
	},
	"TopologicalSort" : {
		"prefix": "TopologicalSort",
		"body": [
			"//隣接リストgを利用,n頂点",
			"auto topological_sort = [](vector<vector<ll>> &g,ll n){",
			"  vector<ll> topological_order;",
			" ",
			"  vector<ll> in_cnt(n);//入次数",
			"  rep(i,n){",
			"    for(ll p : g[i]){",
			"      in_cnt[p]++;",
			"    }",
			"  }",
			"  queue<ll> que;",
			"  //始点入れる",
			"  rep(i,n){",
			"    if(in_cnt[i] == 0){",
			"      que.push(i);",
			"    }",
			"  }",
			" ",
			"  while(!que.empty()){",
			"    ll now  = que.front();",
			"    que.pop();",
			"    topological_order.push_back(now);",
			"    for(ll p :g[now]){",
			"      if(in_cnt[p] > 0){",
			"        in_cnt[p]--;",
			"        if(in_cnt[p] == 0){",
			"          que.push(p);",
			"        }",
			"      }",
			"    }",
			"  }",
			"  return topological_order;",
			"};"
			
		],
		"description": "template for topologicalsort"
	},
	"Dijecstra" : {
		"prefix": "Daijecstra",
		"body": [
			"using P = pair<ll,ll>;",
			" ",
			"void Dijkstra(vector<ll> &dis,vector<vector<pair<ll,ll>>> &G,ll s){",
			"  // G[i]<j,d> i->j の距離(d)",
			"  // 「仮の最短距離, 頂点」が小さい順に並ぶ",
			"  priority_queue<P,vector<P>,greater<P>>pq;",
			"  dis[s] = 0;",
			"  pq.push({dis[s],s});",
			"  while(!pq.empty()){",
			"    auto [len,now] = pq.top();",
			"    pq.pop();",
			"    if(dis[now]< len){",
			"      continue;",
			"    }",
			"    for(auto &p:G[now]){",
			"      // 注意！",
			"      auto [next,cost] = p;",
			"      if(dis[next] > dis[now] + cost){",
			"        dis[next] = dis[now] + cost;",
			"        pq.push({dis[next],next});",
			"      }",
			"    }",
			"  }",
			"}"
		],
		"description": "template for Dijecstra"
	},
	"Kruskal" : {
		"prefix": "Kurasukaru",
		"body": [
			"/*",
			"小さい辺から見ていって２頂点が同じグループになければそのへんを追加する",
			"*/",
			" ",
			"ll kruskal(priority_queue<pair<ll,pair<ll,ll>>,vector<pair<ll,pair<ll,ll>>>,greater<pair<ll,pair<ll,ll>>>> pq,ll v){",
			"  dsu uf(v);",
			"  ll sum = 0;",
			"  while(!pq.empty()){",
			"    ll len = pq.top().first;",
			"    auto [a,b] = pq.top().second;",
			"    pq.pop();",
			"    if(!uf.same(a,b)){",
			"      sum += len;",
			"      uf.merge(a,b);",
			"    }",
			"  }",
			"  return sum;",
			"}"
		],
		"description": "template for Kruskal"
	},
	"UnionFind" : {
		"prefix": "UnionFind",
		"body": [
			"class UnionFind{",
			"  public:",
			"  vector<ll> par;",
			"  vector<ll> siz;",
			" ",
			"  UnionFind(ll n) {",
			"    par.resize(n,-1);",
			"    siz.resize(n,1);",
			"    _n = n;",
			"  }",
			" ",
			"  ll leader(ll a){",
			"    assert(0 <= a && a < _n);",
			"    while(par[a] != -1){",
			"      a = par[a];",
			"    }",
			"    return a;",
			"  }",
			" ",
			"  ll size(ll a){",
			"    assert(0 <= a && a < _n);",
			"    return siz[leader(a)];",
			"  }",
			" ",
			"  ll merge(ll a,ll b){",
			"    assert(0 <= a && a < _n);",
			"    assert(0 <= b && b < _n);",
			"    ll u = leader(a);",
			"    ll v = leader(b);",
			"    if( u == v )return u;",
			"    if(siz[u] >= siz[v]){",
			"      par[v] = u;",
			"      siz[u] += siz[v];",
			"      return u;",
			"    }else{",
			"      par[u] = v;",
			"      siz[v] += siz[u];",
			"      return v;",
			"    }",
			"  }",
			" ",
			"  bool same(ll a,ll b){",
			"    assert(0 <= a && a < _n);",
			"    assert(0 <= b && b < _n);",
			"    if(leader(a) == leader(b)){",
			"      return true;",
			"    }else{",
			"      return false;",
			"    }",
			"  }",
			" ",
			"  vector<vector<ll>> groups(){",
			"    map<ll,vector<ll>> mp;",
			"    for(ll i = 0;i < _n;i++){",
			"      mp[leader(i)].push_back(i);",
			"    }",
			"    vector<vector<ll>> ans;",
			"    for(auto &p:mp){",
			"      vector<ll> now = p.second;",
			"      ans.push_back(now);",
			"    }",
			"    return ans;",
			"  }",
			" ",
			"  private:",
			"  ll _n;",
			"};"

		],
		"description": "template for UnionFind"
	},
	"SegmentTree" : {
		"prefix": "SegmentTree",
		"body": [
			"template <class T>",
			"class SegmentTree{",
			"  public:",
			"  vector<T> tree;",
			"  ll siz = 0;",
			"  T e; //単位元 初期化に使われるやつ",
			"  function<T(T,T)> op;",
			"  function<T(T,T)> mapping = [](T a,T b){return b;};//更新に使用 デフォルトはただ更新",
			" ",
			"  //とりあえず定義したい時用",
			"  SegmentTree():e(0),op([](T a,T b){return 0;}){",
			"    tree.resize(1 << 1,0);",
			"    siz = 1 << 0;",
			"  }",
			"  ",
			"  SegmentTree(ll n,T _e,function<T(T,T)> _op):e(_e),op(_op){",
			"    ll i = 0;",
			"    while((1 << i) < n ){",
			"      i++;",
			"    }",
			"    tree.resize(1<<(i+1),_e);",
			"    siz = 1 << i;",
			"  }",
			" ",
			"  //更新も工夫したいやつ",
			"  SegmentTree(ll n,T _e,function<T(T,T)> _op,function<T(T,T)>_mapping):e(_e),op(_op),mapping(_mapping){",
			"    ll i = 0;",
			"    while((1 << i) < n ){",
			"      i++;",
			"    }",
			"    tree.resize(1<<(i+1),_e);",
			"    siz = 1 << i;",
			"  }",
			"  ",
			"  void update(ll pos, T x){",
			"    pos = pos + siz-1;",
			"    tree[pos] = mapping(tree[pos],x);",
			"    while(pos >= 1){",
			"      pos = (pos-1)/2;",
			"      tree[pos] = op(tree[2 * pos +1], tree[2 * (pos+1)]);",
			"    }",
			"  }",
			" ",
			"  //[l,r) について、最初はa = 0,b = (SegmentTree).siz, p = 0 にしておく ",
			"  T _query(ll l, ll r, ll a, ll b, ll p){",
			"    if(r <= a or l >= b){",
			"      return e;",
			"    }",
			"    if(l <= a and b <= r){",
			"      return tree[p];",
			"    }",
			"    ll m = (a + b)/2;",
			"    T ansl = _query(l,r,a,m,2 * p+1);",
			"    T ansr = _query(l,r,m,b,2 * (p+1));",
			"    return op(ansl,ansr);",
			"  }",
			" ",
			"  //query呼び出し用[l,r)",
			"  T query(ll l,ll r){",
			"    return _query(l,r,0,siz,0);",
			"  }",
			" ",
			"  T operator[](ll pos){",
			"    return tree[pos + siz -1];",
			"  }",
			"  ",
			"};"
		],
		"description": "template for SegmentTree"
	},
	"SCC_graph" : {
		"prefix": "Scc_graph",
		"body": [
			"struct Scc_graph{",
			"  vector<vector<ll>> g;",
			"  ll _n;",
			" ",
			"  Scc_graph(ll n): _n(n){",
			"    g.resize(n);",
			"  }",
			" ",
			"  void add_edge(ll from,ll to){",
			"    assert(0 <= from && from < _n);",
			"    assert(0 <= to && to < _n);",
			"    g[from].push_back(to);",
			"  }",
			" ",
			"  vector<vector<ll>> scc(){",
			"    ll now_ord = 0,group_num = 0;//dfs行きかけで発見した頂点数、グループの数",
			"    vector<ll> visited;//発見したけどまだグループ分けされてない頂点",
			"    vector<ll> low(_n);//lowlink",
			"    vector<ll> ord(_n,-1);//order何番目に発見したか",
			"    vector<ll> ids(_n);//groupidが振られる",
			" ",
			"    auto dfs = [&](auto dfs,ll v)-> void{",
			"      ord[v] = now_ord;",
			"      low[v] = now_ord;",
			"      now_ord++;",
			"      visited.push_back(v);",
			"      for(auto &p:g[v]){",
			"        if(ord[p] == -1){",
			"          dfs(dfs,p);",
			"          low[v] = min(low[v],low[p]);",
			"        }else{",
			"          low[v] = min(low[v],ord[p]);//ord[p] == _nならグループに分けられてる",
			"        }",
			"      }",
			"      if(low[v] == ord[v]){",
			"        //scc_rootだった",
			"        while(true){",
			"          ll u = visited.back();",
			"          visited.pop_back();",
			"          ord[u] = _n;//グループに分けられた  ",
			"          ids[u] = group_num;",
			"          if(u == v)break;",
			"        }",
			"        group_num++;",
			"      } ",
			"    };",
			"    rep(i,_n){",
			"      if(ord[i] == -1){",
			"        dfs(dfs,i);",
			"      }",
			"    }",
			"    //group番号を逆順にする",
			"    for(auto &p:ids){",
			"      p = group_num - 1 - p;",
			"    }",
			"    vector<vector<ll>> groups(group_num);",
			"    rep(i,_n){",
			"      groups[ids[i]].push_back(i);",
			"    }",
			"    return groups;",
			"  }",
			" ",
			"};",
		],
		"description": "template for Scc_graph"
	},
	"RSQ" : {
		"prefix": "RSQ",
		"body": [
			"class RSQ{",
			"  public:",
			"  vector<ll> tree;",
			"  ll siz = 0;",
      "  RSQ(){}",
			"  RSQ(ll n){",
			"    ll i = 0;",
			"    while((1 << i) < n ){",
			"      i++;",
			"    }",
			"    tree.resize(1<<(i+1));",
			"    siz = 1 << i;",
			"  }",
			" ",
			"  void init(ll n){",
			"    ll i = 0;",
			"    while((1 << i) < n ){",
			"      i++;",
			"    }",
			"    tree.resize(1<<(i+1));",
			"    siz = 1 << i;",
			"  }",
			"  ",
			"  void update(ll pos, ll x){",
			"    pos = pos + siz-1;",
			"    tree[pos] = x;",
			"    while(pos >= 1){",
			"      pos = (pos-1)/2;",
			"      tree[pos] = tree[2 * pos +1]+tree[2 * (pos+1)];",
			"    }",
			"  }",
			"  //[l,r) について、最初はa = 0,b = (SegmentTree).siz, p = 0 にしておく",
			"  ll _query(ll l, ll r, ll a, ll b, ll p){",
			"    if(r <= a or l >= b){",
			"      return 0;",
			"    }",
			"    if(l <= a and b <= r){",
			"      return tree[p];",
			"    }",
			"    ll m = (a + b)/2;",
			"    ll ansl = _query(l,r,a,m,2 * p+1);",
			"    ll ansr = _query(l,r,m,b,2 * (p+1));",
			"    return ansl + ansr;",
			"  }",
			" ",
			"  ll query(ll l ,ll r){",
			"    return _query(l,r,0,siz,0);",
			"  }",
			" ",
			"  ll operator[](ll pos){",
			"    return tree[pos + siz -1];",
			"  }",
			"};"
		],
		"description": "template for RSQ"
	},
	"RMQ" : {
		"prefix": "RMQ",
		"body": [
			"class RMQ{",
			"  public:",
			"  vector<ll> tree;",
			"  ll siz = 0;",
      "  RMQ(){}",
			"  RMQ(ll n){",
			"    ll i = 0;",
			"    while((1 << i) < n ){",
			"      i++;",
			"    }",
			"    tree.resize(1<<(i+1));//ここ変えたらquery内も変える",
			"    siz = 1 << i;",
			"  }",
			" ",
			"  void init(ll n){",
			"    ll i = 0;",
			"    while((1 << i) < n ){",
			"      i++;",
			"    }",
			"    tree.resize(1<<(i+1));",
			"    siz = 1 << i;",
			"  }",
			"  ",
			"  void update(ll pos, ll x){",
			"    pos = pos + siz-1;",
			"    tree[pos] = x;",
			"    while(pos >= 1){",
			"      pos = (pos-1)/2;",
			"      tree[pos] = max(tree[2 * pos +1], tree[2 * (pos+1)]);",
			"    }",
			"  }",
			" ",
			"  //[l,r) について、最初はa = 0,b = (SegmentTree).siz, p = 0 にしておく ",
			"  ll _query(ll l, ll r, ll a, ll b, ll p){",
			"    if(r <= a or l >= b){",
			"      return 0;",
			"    }",
			"    if(l <= a and b <= r){",
			"      return tree[p];",
			"    }",
			"    ll m = (a + b)/2;",
			"    ll ansl = _query(l,r,a,m,2 * p+1);",
			"    ll ansr = _query(l,r,m,b,2 * (p+1));",
			"    return max(ansl,ansr);",
			"  }",
			"  ",
			"  ll query(ll l ,ll r){",
			"    return _query(l,r,0,siz,0);",
			"  }",
			" ",
			"  ll operator[](ll pos){",
			"    return tree[pos + siz -1];",
			"  }",
			"};"
		],
		"description": "template for RMQ"
	},
	"RmQ" : {
		"prefix": "RmQ",
		"body": [
			"class RmQ{",
			"  public:",
			"  vector<ll> tree;",
			"  ll siz = 0;",
      "  RmQ(){}",
			"  RmQ(ll n){",
			"    ll i = 0;",
			"    while((1 << i) < n ){",
			"      i++;",
			"    }",
			"    tree.resize(1<<(i+1),INF);",
			"    siz = 1 << i;",
			"  }",
			" ",
			"  void init(ll n){",
			"    ll i = 0;",
			"    while((1 << i) < n ){",
			"      i++;",
			"    }",
			"    tree.resize(1<<(i+1),INF);",
			"    siz = 1 << i;",
			"  }",
			"  ",
			"  void update(ll pos, ll x){",
			"    pos = pos + siz-1;",
			"    tree[pos] = x;",
			"    while(pos >= 1){",
			"      pos = (pos-1)/2;",
			"      tree[pos] = min(tree[2 * pos +1], tree[2 * (pos+1)]);",
			"    }",
			"  }",
			" ",
			"  //[l,r) について、最初はa = 0,b = (SegmentTree).siz, p = 0 にしておく ",
			"  ll _query(ll l, ll r, ll a, ll b, ll p){",
			"    if(r <= a or l >= b){",
			"      return INF;",
			"    }",
			"    if(l <= a and b <= r){",
			"      return tree[p];",
			"    }",
			"    ll m = (a + b)/2;",
			"    ll ansl = _query(l,r,a,m,2 * p+1);",
			"    ll ansr = _query(l,r,m,b,2 * (p+1));",
			"    return min(ansl,ansr);",
			"  }",
			"  ",
			"  ll query(ll l ,ll r){",
			"    return _query(l,r,0,siz,0);",
			"  }",
			" ",
			"  ll operator[](ll pos){",
			"    return tree[pos + siz -1];",
			"  }",
			"};"
		],
		"description": "template for RmQ"
	},
	"nCk_strong" : {
		"prefix": "nCk_strong",
		"body": [
			"//最強,前処理(n), 計算(1)",
			"//n,k <= 10^7の時",
			"const ll MOD = 998244353;",
			"vector<long long> fact, fact_inv, inv;",
			"/*  init_nCk :二項係数のための前処理",
			"    計算量:O(n)",
			"*/",
			"void init_nCk(ll SIZE) {",
			"    fact.resize(SIZE + 5);",
			"    fact_inv.resize(SIZE + 5);",
			"    inv.resize(SIZE + 5);",
			"    fact[0] = fact[1] = 1;",
			"    fact_inv[0] = fact_inv[1] = 1;",
			"    inv[1] = 1;",
			"    for (int i = 2; i < SIZE + 5; i++) {",
			"        fact[i] = fact[i - 1] * i % MOD;",
			"        inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;//iの逆元",
			"        fact_inv[i] = fact_inv[i - 1] * inv[i] % MOD;//i!の逆元",
			"    }",
			"}",
			"/*  nCk :MODでの二項係数を求める(前処理 int_nCk が必要)",
			"    計算量:O(1)",
			"*/",
			"long long nCk(ll n, ll k) {",
			"    assert(!(n < k));",
			"    assert(!(n < 0 || k < 0));",
			"    return fact[n] * (fact_inv[k] * fact_inv[n - k] % MOD) % MOD;",
			"}"

		],
		"description": "template for nCk_strong"
	},
	"nCk_strong2" : {
		"prefix": "nCk_strong2",
		"body": [
			"/*",
			"k <= 10^7 n<= 10^9の時",
			"nが固定でない時",
			"*/",
			"ll MOD = 1e9+ 7;",
			"vector<ll> fact_inv,inv;",
			" ",
			"/*  init_nCk :二項係数のための前処理",
			"    計算量:O(k)",
			"*/",
			"void init_nCk(ll siz){",
			" fact_inv.resize(siz + 5);",
			" inv.resize(siz +5);",
			" fact_inv[0] = 1;",
			" fact_inv[1] = 1;",
			" inv[1] = 1;",
			" for(ll i = 2;i < siz +5;i++){",
			"   inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;",
			"   fact_inv[i] = fact_inv[i-1] * inv[i] % MOD;",
			" }",
			"}",
			"/*  nCk :MODでの二項係数を求める(前処理 init_nCk が必要)",
			"    計算量:O(k)",
			"     n/1 * (n-1)/2 * ... *(n-k+1)/kを計算する",
			"*/",
			"ll nCk(ll n,ll k){",
			" assert(!(n < k));",
			"  assert(!(n < 0 || k < 0));",
			" ll ans = 1;",
			" for(ll i = n;i >= n-k+1;i--){",
			"   ans *= i;",
			"   ans %= MOD;",
			" }",
			" return ans * fact_inv[k] % MOD;",
			"}"

		],
		"description": "template for nCk k <= 10^7 n<= 10^9の時,n固定でないとき"
	},
	"nCk_strong3" : {
		"prefix": "nCk_strong3",
		"body": [
			"/*",
			"k <= 10^7 n<= 10^9の時",
			"nが固定の時",
			"*/",
			"ll MOD = 1e9+ 7;",
			" ",
			"//fact_inv: i!の逆元",
			"//inv     : iの逆元",
			"//Com     : nCiの答え",
			"vector<ll> fact_inv,inv,Com;",
			" ",
			"/*  init_nCk :二項係数のための前処理",
			"    計算量:O(k)",
			"*/",
			"void init_nCk(ll n,ll siz){",
			" fact_inv.resize(siz + 5);",
			" inv.resize(siz +5);",
			" fact_inv[0] = 1;",
			" fact_inv[1] = 1;",
			" inv[1] = 1;",
			" for(ll i = 2;i < siz +5;i++){",
			"   inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;",
			"   fact_inv[i] = fact_inv[i-1] * inv[i] % MOD;",
			" }",
			" Com.resize(siz + 5);",
			" Com[0] = 1;",
			" //n/1 * (n-1)/2 * ... *(n-k+1)/kを計算する",
			" for(ll i = 1;i < siz + 5;i++){",
			"   Com[i] = Com[i-1] *((n-i+1) *inv[i] % MOD)%MOD;",
			" }",
			"}",
			"/*  nCk :MODでの二項係数を求める(前処理 init_nCk が必要)",
			"    計算量:O(1)",
			"*/",
			"ll nCk(ll k){",
			" assert(!(k < 0));",
			" return Com[k];",
			"}"
		],
		"description": "template for nCk k <= 10^7 n<= 10^9の時,n固定のとき"
	},
	"nCk_not_sosu" : {
		"prefix": "nCk_not_sosu",
		"body": [
			"/*",
			"MODが素数でない時も使える",
			"k,n <= 5000",
			"nCk = (n-1)C(k-1) + (n-1)Ckを利用したDP",
			"*/",
			"const int MAX_N = 5000;",
			"const long long MOD = 1000000007;",
			"long long Com[MAX_N][MAX_N];",
			"/* init_nCk:二項係数のための前処理",
			"    計算量:O(MAX_N*MAX_N)",
			"*/",
			"void init_nCk() {",
			"    memset(Com, 0, sizeof(Com));",
			"    Com[0][0] = 1;",
			"    for (int i = 1; i < MAX_N; ++i) {",
			"        Com[i][0] = 1;",
			"        for (int j = 1; j < MAX_N; j++) {",
			"            Com[i][j] = (Com[i - 1][j - 1] + Com[i - 1][j]) % MOD;",
			"        }",
			"    }",
			"}",
			"/*  nCk :MODでの二項係数を求める(前処理 int_nCk が必要)",
			"    計算量:O(1)",
			"*/",
			"long long nCk(int n, int k) {",
			"    assert(!(n < k));",
			"    assert(!(n < 0 || k < 0));",
			"    return Com[n][k];",
			"}"

		],
		"description": "template for nCk MODが素数でないときもOK、k,n <= 5000"
	},
	"nCk_not_MOD" : {
		"prefix": "nCk_not_MOD",
		"body": [
			"// Mod使わずllに収まる範囲でオーバーフローしないやつ",
			" ",
			"#define CMAX 1010",
			"ll noinit = 1; ll memo[CMAX][CMAX];",
			"ll nCr(ll a, ll b) {",
			"    if (noinit) {",
			"        rep(i, CMAX) rep(j, CMAX) memo[i][j] = -1;",
			"        noinit = 0;",
			"    }",
			"    if (b == 0 || a == b) return 1;",
			"    if (0 <= memo[a][b]) return memo[a][b];",
			"    return memo[a][b] = nCr(a - 1, b - 1) + nCr(a - 1, b);",
			"}"
		],
		"description": "template for nCk MOD取らなくてオーバーフローしないとき"
	},
	"Mint" : {
		"prefix": "Mint",
		"body": [
			"template<uint32_t m> class static_modint {",
			"    using mint = static_modint;",
			"    uint32_t _v = 0;",
			"    static constexpr bool prime = []() -> bool {",
			"        if (m == 1) return 0;",
			"        if (m == 2 || m == 7 || m == 61) return 1;",
			"        if (m % 2 == 0) return 0;",
			"        uint32_t d = m - 1;",
			"        while (d % 2 == 0) d /= 2;",
			"        for (uint32_t a : {2, 7, 61}) {",
			"            uint32_t t = d;",
			"            mint y = mint(a).pow(t);",
			"            while (t != m - 1 && y != 1 && y != m - 1) {",
			"                y *= y; t <<= 1;",
			"            }",
			"            if (y != m - 1 && t % 2 == 0) return 0;",
			"        }",
			"        return 1;",
			"    }();",
			"    static constexpr pair<int32_t, int32_t> inv_gcd(int32_t a, int32_t b) {",
			"        if (a == 0) return {b, 0};",
			"        int32_t s = b, t = a, m0 = 0, m1 = 1;",
			"        while (t) {",
			"            const int32_t u = s / t;",
			"            s -= t * u; m0 -= m1 * u;",
			"            swap(s, t); swap(m0, m1);",
			"        }",
			"        if (m0 < 0) m0 += b / s;",
			"        return {s, m0};",
			"    }",
			"public:",
			"    static constexpr mint raw(uint32_t v) { mint a; a._v = v; return a; }",
			"    constexpr static_modint() {}",
			"    template <class T>",
			"    constexpr static_modint(T v) {",
			"        static_assert(is_integral_v<T>, \"T is not integral type.\");",
			"        if constexpr (is_signed_v<T>) {",
			"            int64_t x = int64_t(v % int64_t(m));",
			"            if (x < 0) x += m; _v = uint32_t(x);",
			"        }",
			"        else _v = uint32_t(v % m);",
			"    }",
			"    static constexpr uint32_t mod() { return m; }",
			"    constexpr uint32_t val() const { return _v; }",
			"    constexpr mint& operator++() { return *this += 1; }",
			"    constexpr mint& operator--() { return *this -= 1; }",
			"    constexpr mint operator++(int) { mint res = *this; ++*this; return res; }",
			"    constexpr mint operator--(int) { mint res = *this; --*this; return res; }",
			"    constexpr mint& operator+=(mint rhs) {",
			"        if (_v >= m - rhs._v) _v -= m;",
			"        _v += rhs._v; return *this;",
			"    }",
			"    constexpr mint& operator-=(mint rhs) {",
			"        if (_v < rhs._v) _v += m;",
			"        _v -= rhs._v; return *this;",
			"    }",
			"    constexpr mint& operator*=(mint rhs) { return *this = *this * rhs; }",
			"    constexpr mint& operator/=(mint rhs) { return *this *= rhs.inv(); }",
			"    constexpr mint operator+() const { return *this; }",
			"    constexpr mint operator-() const { return mint{} - *this; }",
			"    constexpr mint pow(long long n) const {",
			"        assert(0 <= n);",
			"        if(n == 0) return 1;",
			"        mint x = *this, r = 1;",
			"        while (1) {",
			"            if (n & 1) r *= x; n >>= 1;",
			"            if (n == 0) return r;",
			"            x *= x;",
			"        }",
			"    }",
			"    constexpr mint inv() const {",
			"        if constexpr (prime) {",
			"            assert(_v);",
			"            return pow(m - 2);",
			"        } else {",
			"            auto eg = inv_gcd(_v, m);",
			"            assert(eg.first == 1);",
			"            return eg.second;",
			"        }",
			"    }",
			"    friend constexpr mint operator+(mint lhs, mint rhs) { return lhs += rhs; }",
			"    friend constexpr mint operator-(mint lhs, mint rhs) { return lhs -= rhs; }",
			"    friend constexpr mint operator*(mint lhs, mint rhs) { return uint64_t(lhs._v) * rhs._v; }",
			"    friend constexpr mint operator/(mint lhs, mint rhs) { return lhs /= rhs; }",
			"    friend constexpr bool operator==(mint lhs, mint rhs) { return lhs._v == rhs._v; }",
			"    friend constexpr bool operator!=(mint lhs, mint rhs) { return lhs._v != rhs._v; }",
			"};",
			"using modint998244353 = static_modint<998244353>;",
			"using modint1000000007 = static_modint<1000000007>;"

		],
		"description": "template for Mint"
	},
	"LCA" : {
		"prefix": "LCA",
		"body": [
			"//verify https://onlinejudge.u-aizu.ac.jp/solutions/problem/GRL_5_C/review/8911290/T21140031/C++17",
			"//1indexed",
			"template <class T>",
			"class SegmentTree{",
			"  public:",
			"  vector<T> tree;",
			"  ll siz = 0;",
			"  T e; //単位元 初期化に使われるやつ",
			"  function<T(T,T)> op;",
			"  function<T(T,T)> mapping = [](T a,T b){return b;};//更新に使用 デフォルトはただ更新",
			"",
			"  SegmentTree(){}",
			"  ",
			"  SegmentTree(ll n,T _e,function<T(T,T)> _op):e(_e),op(_op){",
			"    ll i = 0;",
			"    while((1 << i) < n ){",
			"      i++;",
			"    }",
			"    tree.resize(1<<(i+1),_e);",
			"    siz = 1 << i;",
			"  }",
			" ",
			"  //更新も工夫したいやつ",
			"  SegmentTree(ll n,T _e,function<T(T,T)> _op,function<T(T,T)>_mapping):e(_e),op(_op),mapping(_mapping){",
			"    ll i = 0;",
			"    while((1 << i) < n ){",
			"      i++;",
			"    }",
			"    tree.resize(1<<(i+1),_e);",
			"    siz = 1 << i;",
			"  }",
			"  ",
			"  void update(ll pos, T x){",
			"    pos = pos + siz;",
			"    tree[pos] = mapping(tree[pos],x);",
			"    while(pos>=2){",
			"      pos >>=1;",
			"      tree[pos] = op(tree[pos << 1|0], tree[pos<<1|1]);",
			"    }",
			"  }",
			"",
			"  //[l,r)",
			"  T query(ll l,ll r){",
			"    T retl = e,retr = e;",
			"    l += siz;",
			"    r += siz;",
			"    while(l < r){",
			"      if(l & 1)retl = op(retl,tree[l++]);//演算してから足す",
			"      if(r & 1)retr = op(tree[--r],retr);//演算する前に引く",
			"      l>>=1;r>>=1;",
			"    }",
			"    return op(retl,retr);",
			"  }",
			" ",
			"  T operator[](ll pos){",
			"    return tree[pos + siz];",
			"  }",
			"  ",
			"};",
			"",
			"struct EulerTour{",
			"  vector<ll> fa,la;//頂点vがDFS探索順で最初に現れた時間とその頂点を抜けた時間",
			"  vector<ll> depth;",
			"  vector<pair<ll,ll>> euler_tour;//dfsしたときに現れる頂点の(深さ、頂点番号)",
			"  EulerTour(){}",
			"  EulerTour(ll n,vector<vector<ll>> &g){",
			"    fa.resize(n);la.resize(n);",
			"    depth.resize(n,INF);",
			"    depth[0] = 0;",
			"    dfs_euler(g,0);",
			"  }",
			"",
			"  void dfs_euler(vector<vector<ll>> &g,ll v){",
			"    fa[v] = euler_tour.size();",
			"    euler_tour.push_back({depth[v],v});",
			"    for(auto &p:g[v]){",
			"      if(depth[p] == INF){",
			"        depth[p] = depth[v] + 1;",
			"        dfs_euler(g,p);",
			"        euler_tour.push_back({depth[v],v});",
			"      }",
			"    }",
			"    la[v] = euler_tour.size()-1;",
			"  }",
			"};",
			"",
			"struct LCA{",
			"  SegmentTree<pair<ll,ll>> seg_euler;",
			"  EulerTour et;",
			"  LCA(){}",
			"  LCA(ll n,vector<vector<ll>> &g){//頂点数と隣接リスト",
			"    et = EulerTour(n,g);",
			"    ",
			"    seg_euler = SegmentTree<pair<ll,ll>>((ll)et.euler_tour.size(),{INF,INF},[](pair<ll,ll> a,pair<ll,ll> b){return min(a,b) == a ? a : b;});",
			"    seg_euler_setup(seg_euler);",
			"  }",
			"",
			"  //euler_tourの情報をSeg木に乗せるだけ",
			"  void seg_euler_setup(SegmentTree<pair<ll,ll>> &seg_euler){",
			"    ll siz = et.euler_tour.size();",
			"    rep(i,siz){",
			"      seg_euler.update(i,et.euler_tour[i]);",
			"    }",
			"  }",
			"",
			"  // x,yのLCA求める({深さ,頂点番号})",
			"  pair<ll,ll> query(ll x,ll y){",
			"    return seg_euler.query(min(et.fa[x],et.fa[y]),max(et.fa[x],et.fa[y])+1);",
			"  }",
			"};"

		],
		"description": "template for LCA"
	},
	"RollingHash" : {
		"prefix": "RollingHash",
		"body": [
      "//参考 https://drken1215.hatenablog.com/entry/2019/03/12/135500",
"//https://qiita.com/keymoon/items/11fac5627672a6d6a9f6",
"//verify https://atcoder.jp/contests/tessoku-book/submissions/52829138",
"struct RollingHash{",
"",
"  const ull MASK30 = (1UL << 30) - 1;",
"  const ull MASK31 = (1UL << 31) - 1;",
"  const ull MOD = (1UL << 61) - 1;",
"  const ull MASK61 = MOD;",
"  const ull POSITIVIZER = MOD * 4;",
"  const ull base = 9973;",
"",
"",
"  string s;",
"  vector<ull> hash;",
"",
"  RollingHash(){}",
"",
"  RollingHash(const string &_s){",
"    init(_s);",
"  }",
"",
"  //mod 2^61-1を計算する関数",
"  ull CalcMod(ull x)",
"  {",
"      ull xu = x >> 61;",
"      ull xd = x & MASK61;",
"      ull res = xu + xd;",
"      if (res >= MOD) res -= MOD;",
"      return res;",
"  }",
"  //a*b mod 2^61-1を返す関数(最後にModを取る)",
"  ull Mul(ull a, ull b)",
"  {",
"      ull au = a >> 31;",
"      ull ad = a & MASK31;",
"      ull bu = b >> 31;",
"      ull bd = b & MASK31;",
"      ull mid = ad * bu + au * bd;",
"      ull midu = mid >> 30;",
"      ull midd = mid & MASK30;",
"      return CalcMod(au * bu * 2 + midu + (midd << 31) + ad * bd);",
"  }",
"  ",
"  //2^61 -1 で割る時のpow計算",
"  ",
"  ull SuperMODpow(ll x,ll n){",
"    // MOD = (1UL << 61) - 1;,Mul,CalcMod必要",
"    ull ans = 1;",
"    ull a = x;",
"    while(n> 0){",
"      if(n & 1){",
"        ans = Mul(ans,a);",
"      }",
"      a = Mul(a,a);",
"      n>>=1;",
"    }",
"    return ans;",
"  }",
"",
"  void init(const string &_s){",
"    s = _s;",
"    ll n = s.size();",
"    hash.assign(n+1,0);",
"    rep(i,n){",
"      hash[i + 1] = CalcMod((Mul(hash[i],base) + s[i]));",
"    }",
"  }",
"",
"  //[l,r)のハッシュを返す",
"  inline ull get(ll l,ll r){",
"    return CalcMod(hash[r]+ POSITIVIZER - Mul(hash[l],SuperMODpow(base,r-l)));",
"  }",
"};",

		],
		"description": "template for RollingHash"
	},
	"BFS" : {
		"prefix": "BFS",
		"body": [
			"queue<ll> que;",
			"//0からの距離が入る",
      "//01BFSのときは更新の判定のところを変更する",
			"vector<ll> find(n,INF);",
			"find[0] = 0;",
			"que.push(0);",
			"while(!que.empty()){",
			"  ll now = que.front();",
			"  que.pop();",
			"  for(auto &p:g[now]){",
      "    if(find[p] > find[now]+1){",
			"      find[p] = find[now]+1;",
			"      que.push(p);",
			"    }",
			"  }",
			"}"

		],
		"description": "template for BFS"
	},
	"BellmanFord" : {
		"prefix": "Berumanford",
		"body": [
			"//負の閉検出、負の辺ありで単一始点最短経路",
			" ",
			"struct Edge{",
			" ll from;",
			" ll to;",
			" ll cost;",
			"};",
			" ",
			"// 負の閉路が存在する場合 true を返し, 負閉路の影響を受ける頂点は -INF にセットされる",
			"// dist は頂点数と同じサイズ, 全要素 INF で初期化しておく",
			"// startからgoalの経路知りたいときは適宜変更",
			"bool BellmanFord(vector<Edge> &edges,vector<ll> &dist,ll start,ll goal = -1){",
			" dist[start] = 0;",
			" ",
			" vector<ll> parent(dist.size(),-1);",
			" ",
			" rep(i,dist.size()){",
			"   bool changed = false;",
			"   for(auto &p:edges){",
			"     if(dist[p.from] == INF){",
			"       continue;",
			"     }",
			"     if(dist[p.from] + p.cost < dist[p.to]){",
			"       dist[p.to] = dist[p.from] + p.cost;",
			"       parent[p.to] = p.from;//直前の頂点を記憶",
			"       changed = true;",
			"     }",
			"   }",
			" ",
			"   //頂点の更新がなくなったら終了",
			"   if(changed == false){",
			"     return false;",
			"   }",
			" }",
			" ",
			" //頂点数だけ更に繰り返して負の閉路を受ける点を-INFにしていく",
			" rep(i,dist.size()){",
			"   for(auto &p:edges){",
			"     if(dist[p.from] == INF){",
			"       continue;",
			"     }",
			"     //まだ更新されるってことは負の閉路の影響をうけて無限に小さくなってしまう",
			"     if(dist[p.from] + p.cost < dist[p.to]){",
			"       dist[p.to] = -INF;",
			"     }",
			"   }",
			" }",
			" vector<ll> ret;",
			" if(goal != -1 && dist[goal] != INF && dist[goal] != -INF){",
			"   for(ll i = goal;i != -1;i = parent[i]){",
			"     ret.push_back(i);",
			"   }",
			" }",
			" reverse(all(ret));",
			" //必要ならretを出力してstartからgoalまでの経路を出力する",
			" ",
			" ",
			" return true;",
			"}"

		],
		"description": "template for BellmanFord"
	},
	"LazySegmentTree" : {
		"prefix": "LazySegmentTree",
		"body": [
			"template<class X,class M>",
			"struct LazySegmentTree{",
			" using FX = function<X(X,X)>;",
			" using FA = function<X(X,M)>;",
			" using FM = function<M(M,M)>;",
			" using FP = function<M(M,ll)>;",
			" ll siz;",
			" FX fx; FA fa; FM fm; FP fp;",
			" const X ex;//Xの単位元",
			" const M em;//Mの単位元",
			" vector<X> tree;",
			" vector<M> lazy;",
			" ",
			" LazySegmentTree(ll n,FX _fx,FA _fa,FM _fm,FP _fp,X _ex,M _em)",
			" :fx(_fx),fa(_fa),fm(_fm),fp(_fp),ex(_ex),em(_em)",
			" {",
			"   ll i = 0;",
			"   while((1 << i) < n){",
			"     i++;",
			"   }",
			"   tree.resize(1 << (i+1),_ex);",
			"   lazy.resize(1 << (i+1),_em);",
			"   siz = 1 << i;",
			" }",
			" //treeの初期値を入れる,posは0indexed",
			" void set(ll pos, X x){",
			"   tree[pos  + siz -1] = x;",
			" }",
			" /*",
			" siz = 4",
			" tree:",
			"     0",
			"   1   2",
			"  3 4 5 6",
			" */",
			" //set()で入れた値でtreeを更新",
			" void build(){",
			"   for(int i = siz -2;i >= 0;i--){",
			"     tree[i]  = fx(tree[2 * i+1],tree[2 * (i+1)]);",
			"   }",
			" }",
			" //遅延評価",
			" void eval(ll p, ll len){",
			"   if(lazy[p] == em) return ;//更新するものがなければ終了",
			"   if(p < siz-1){",
			"     lazy[2*p+1] = fm(lazy[2*p+1],lazy[p]);",
			"     lazy[2*(p+1)] = fm(lazy[2*(p+1)],lazy[p]);",
			"   }",
			"   tree[p] = fa(tree[p],fp(lazy[p],len));//自身の更新",
			"   lazy[p] = em;",
			" }",
			"",
			" //やりたい区間[l,r),今見ている配列が対応する区間[a,b),今見ている配列の番地p",
			" void _update(ll l, ll r, M x,ll a,ll b,ll p){",
			"   eval(p,b-a);//とりあえずまだ送ってないのがあれば下に伝搬",
			"   // lr <= ab or ab <= lr",
			"   if(r <= a || b <= l){",
			"     //範囲外だった",
			"     return ;",
			"   }",
			"   // l <= ab <= r",
			"   if(l <= a  && b <= r){",
			"     //完全に範囲内",
			"     lazy[p] = fm(lazy[p],x);",
			"     eval(p,b-a);",
			"     return ;",
			"   }",
			"   ll m = (a + b)/2;",
			"   _update(l,r,x,a,m,2 * p+1);",
			"   _update(l,r,x,m,b,2 * (p+1));",
			"   tree[p] = fx(tree[2*p+1],tree[2*(p+1)]);",
			"   ",
			" }",
			" void update(ll l, ll r,M x){",
			"   _update(l,r,x,0,siz,0);",
			" }",
			" ",
			" X _query(ll l,ll r,ll a,ll b,ll p){",
			"   eval(p,b-a);//とりあえずまだ送ってないのを伝搬",
			"   // lr <= ab or ab <= lr",
			"   if(r <= a || b <= l){//範囲外",
			"     return ex;",
			"   }",
			"   // l <= ab <= r",
			"   if(l <= a && b <= r){//完全に範囲内",
			"     return tree[p];",
			"   }",
			"   ll m = (a + b)/2;",
			"   X ansl = _query(l,r,a,m,2 * p+1);",
			"   X ansr = _query(l,r,m,b,2 * (p+1));",
			"   return fx(ansl,ansr);",
			"   ",
			" }",
			" ",
			" X query(ll l,ll r){",
			"   return _query(l,r,0,siz,0);",
			" }",
			" ",
			" X operator[](ll pos){",
			"    return tree[pos + siz -1];",
			"  }",
			" ",
			"};"
		],
		"description": "template for LazySegmentTree"
	},
	"テスト作成" : {
		"prefix": "Maketest",
		"body": [
			"//参照渡しで値を作成して渡す",
"void Maketest(ll &n){",
"//配列を渡すときは最初に.clear()をしておく",
"  random_device seed_gen;",
"  mt19937_64 rnd(seed_gen());",
"  ",
"  uniform_int_distribution<ll> da(1, 10);",
"  uniform_int_distribution<ll> db(0, lpow(10,9));",
"  n = da(rnd);",
"",
"",
"  uniform_int_distribution<ll> dc(0, 1);",
"  uniform_int_distribution<ll> dd(0, 1);",
"}",
"",
"void myans(){",
"  //答えの型注意",
"}",
"",
"void correct(){",
"  //答えの型注意",
"}",
"",
"void test(){",
"",
"}",
"",
"void nomal(){",
"",
"}",

		],
		"description": "template for test"
	},
	"拡張ユークリッドの互除法" : {
		"prefix": "kakutyouyu-kuriddo",
		"body": [
			"//返り値gcd(a,b)",
			"//ax + by = gcd(a,b)を満たすx,yを参照で返す",
			"ll extGCD(ll a,ll b,ll &x, ll&y){",
			" if(b == 0){",
			"   x = 1;",
			"   y = 0;",
			"   return a;",
			" }",
			" ll d = extGCD(b,a % b,y,x);",
			" y -= a/b * x;",
			" return d;",
			"}"			
		],
		"description": "template for kakutyouyu-kuriddo"
	},
	"CRT" : {
		"prefix": "CRT",
		"body": [
			"//返り値gcd(a,b)",
"//ax + by = gcd(a,b)を満たすx,yを参照で返す",
"ll extGCD(ll a,ll b,ll &x, ll&y){",
"  if(b == 0){",
"    x = 1;",
"    y = 0;",
"    return a;",
"  }",
"  ll d = extGCD(b,a % b,y,x);",
"  y -= a/b * x;",
"  return d;",
"}",
" ",
"// リターン値を (r, m) とすると解は x ≡ r (mod. m)",
"// 解なしの場合は (0, 0) を返す(aclに準拠)",
"// b,mの列の長さが0のときは (0, 1)を返す(aclに準拠)",
"// b:あまり、m:法",
"pair<ll,ll> crt(const vector<ll> &b,const vector<ll> &m){",
"  assert(b.size() == m.size());",
"  if((int)b.size() == 0)return {0,1};",
"  ll r = 0; ll lcm_m = 1;",
"  rep(i,b.size()){",
"    ll p,q;",
"    ll d = extGCD(lcm_m,m[i],p,q);",
"    if((b[i] - r) % d != 0)return {0,0};//解なし",
"    ll tmp = (b[i]-r)/d * p % (m[i]/d);//多分オーバーフロー対策",
"    r += lcm_m * tmp;",
"    lcm_m *= m[i]/d;",
"  }",
"  return {(r % lcm_m+lcm_m)%lcm_m,lcm_m};",
"}",

		],
		"description": "template for CRT"
	},
	"BIT" : {
		"prefix": "BIT",
		"body": [
			"template <class T>",
			"struct BIT{",
			" ll siz;",
			" vector<T> bit;",
			" BIT(ll n){",
			"   siz = n+1;//1indexedで実装のため",
			"   bit.resize(n+1,0);",
			" }",
			" ",
			" /*",
			"       [       1,8        ]",
			"       [   1,4   ]",
			"       [1,2]     [5,6]",
			"       [1]  [3]  [5]  [7]",
			"   idx  1 2  3 4  5  6 7 8",
			" */",
			" ",
			" //bit[p+1] += x",
			" void add(ll p,T x){",
			"   p++;",
			"   for(ll i = p;i < siz;i += (i & -i)){",
			"     bit[i] += x;",
			"   }",
			" }",
			" ",
			" //bit[0] + bit[1] + ... + bit[p]を計算する",
			" T sum(ll p){",
			"   T ret(0);",
			"   for(ll i = p;i >= 1; i-= (i & -i)){",
			"     ret += bit[i];",
			"   }",
			"   return ret;",
			" }",
			" ",
			" T operator [](ll pos){",
			"   return bit[pos+1];",
			" }",
			" ",
			"};",
		],
		"description": "template for BIT"
	},
	"WeightUnionFind" : {
		"prefix": "WeightUnionFInd_omomituki",
		"body": [
			"template<class T>",
			"struct WeightUnionFind{",
			"  ll _n;",
			"  vector<ll> par;",
			"  vector<ll> siz;",
			"  vector<T> diff_weight;",
			" ",
			"  WeightUnionFind(ll n=1,T e=0){",
			"    par.resize(n);",
			"    siz.resize(n);",
			"    diff_weight.resize(n);",
			"    rep(i,n){",
			"      par[i] = -1;siz[i] = 1;diff_weight[i] = e;",
			"    }",
			"    _n = n;",
			"  }",
			" ",
			"  ll leader(ll a){",
			"    assert(0 <= a && a < _n);",
			"    if(par[a] == -1){",
			"      return a;",
			"    }else{",
			"      ll r = leader(par[a]);",
			"      diff_weight[a] += diff_weight[par[a]];",
			"      return par[a] = r;",
			"    }",
			"  }",
			" ",
			"  T weight(ll a){",
			"    leader(a);//重みの更新",
			"    return diff_weight[a]; ",
			"  }",
			" ",
			"  ll size(ll a){",
			"    assert(0 <= a && a < _n);",
			"    return siz[leader(a)];",
			"  }",
			" ",
			"  // weight(b) - weight(a) = w となるように merge する",
			"  bool merge(ll a,ll b,T w){",
			"    assert(0 <= a && a < _n);",
			"    assert(0 <= b && b < _n);",
			"    w += weight(a);w -=weight(b);//a,bそれぞれrootとの重み差分を修正",
			"    ll u = leader(a);",
			"    ll v = leader(b);",
			"    if( u == v )return false;//同じグループにいた",
			"    if(siz[u] >= siz[v]){",
			"      par[v] = u;",
			"      siz[u] += siz[v];",
			"      diff_weight[v] = w;",
			"      return u;",
			"    }else{",
			"      par[u] = v;",
			"      siz[v] += siz[u];",
			"      diff_weight[u] = -w;",
			"      return v;",
			"    }",
			"  }",
			" ",
			"  T diff(ll a,ll b){",
			"    return weight(b) - weight(a);",
			"  }",
			" ",
			"  bool same(ll a,ll b){",
			"    assert(0 <= a && a < _n);",
			"    assert(0 <= b && b < _n);",
			"    if(leader(a) == leader(b)){",
			"      return true;",
			"    }else{",
			"      return false;",
			"    }",
			"  }",
			" ",
			"  vector<vector<ll>> groups(){",
			"    map<ll,vector<ll>> mp;",
			"    for(ll i = 0;i < _n;i++){",
			"      mp[leader(i)].push_back(i);",
			"    }",
			"    vector<vector<ll>> ans;",
			"    for(auto &p:mp){",
			"      vector<ll> now = p.second;",
			"      ans.push_back(now);",
			"    }",
			"    return ans;",
			"  }",
			" ",
			"};",

		],
		"description": "template for 重み付きUnionFind"
	},
	"非再帰セグ木" : {
		"prefix": "SegmentTree_unrecursion",
		"body": [
			"//1indexed",
			"template <class T>",
			"class SegmentTree{",
			"  public:",
			"  vector<T> tree;",
			"  ll siz = 0;",
			"  T e; //単位元 初期化に使われるやつ",
			"  function<T(T,T)> op;",
			"  function<T(T,T)> mapping = [](T a,T b){return b;};//更新に使用 デフォルトはただ更新",
			" ",
			"  //とりあえず定義したい時用",
			"  SegmentTree():e(0),op([](T a,T b){return 0;}){",
			"    tree.resize(1 << 1,0);",
			"    siz = 1 << 0;",
			"  }",
			"  ",
			"  SegmentTree(ll n,T _e,function<T(T,T)> _op):e(_e),op(_op){",
			"    ll i = 0;",
			"    while((1 << i) < n ){",
			"      i++;",
			"    }",
			"    tree.resize(1<<(i+1),_e);",
			"    siz = 1 << i;",
			"  }",
			" ",
			"  //更新も工夫したいやつ",
			"  SegmentTree(ll n,T _e,function<T(T,T)> _op,function<T(T,T)>_mapping):e(_e),op(_op),mapping(_mapping){",
			"    ll i = 0;",
			"    while((1 << i) < n ){",
			"      i++;",
			"    }",
			"    tree.resize(1<<(i+1),_e);",
			"    siz = 1 << i;",
			"  }",
			"  ",
			"  void update(ll pos, T x){",
			"    pos = pos + siz;",
			"    tree[pos] = mapping(tree[pos],x);",
			"    while(pos>=2){",
			"      pos >>=1;",
			"      tree[pos] = op(tree[pos << 1|0], tree[pos<<1|1]);",
			"    }",
			"  }",
			"",
			"  //[l,r)",
			"  T query(ll l,ll r){",
			"    T retl = e,retr = e;",
			"    l += siz;",
			"    r += siz;",
			"    while(l < r){",
			"      if(l & 1)retl = op(retl,tree[l++]);//演算してから足す",
			"      if(r & 1)retr = op(tree[--r],retr);//演算する前に引く",
			"      l>>=1;r>>=1;",
			"    }",
			"    return op(retl,retr);",
			"  }",
			" ",
			"  T operator[](ll pos){",
			"    return tree[pos + siz];",
			"  }",
			"  ",
			"};"
				
		],
		"description": "template for 非再帰セグ木"
	},
	"Mex" : {
		"prefix": "MexLibrary-mexset",
		"body": [
			"struct mexset{",
			"  set<pair<ll,ll>> se;//両閉区間",
			"  mexset(){",
			"    se.emplace(-INF,-INF);",
			"    se.emplace(INF,INF);",
			"  } ",
			" ",
			"  bool count(ll x){",
			"    auto it = prev(se.lower_bound({x+1,x+1}));",
			"    return (it->first <= x && x <= it->second);",
			"  }",
			"",
			"  bool insert(ll x){",
			"    auto nit = se.lower_bound({x+1,x+1});",
			"    auto[nextf,nexts] = *nit;",
			"    auto it = prev(nit);",
			"    auto[nowf,nows] = *it;",
			"    if(nowf <= x && x <= nows){",
			"      return false;",
			"    }",
			"    if(nows == x-1){",
			"      if(nextf == x+1){",
			"        se.erase(it);",
			"        se.erase(nit);",
			"        se.emplace(nowf,nexts);",
			"      }else{",
			"        se.erase(it);",
			"        se.emplace(nowf,x);",
			"      }",
			"    }else{",
			"      if(nextf == x+1){",
			"        se.erase(nit);",
			"        se.emplace(x,nexts);",
			"      }else{",
			"        se.emplace(x,x);",
			"      }",
			"    }",
			"    return true;",
			"  }",
			"  ll mex(ll x = 0){",
			"    auto [nowf,nows] = *prev(se.lower_bound({x+1,x+1}));",
			"    if(nowf <=x  && x <= nows){",
			"      return nows+1;",
			"    }else{",
			"      return x;",
			"    }",
			"  }",
			"};"
		],
		"description": "template for MexLibrary"
	},
	"非再帰遅延セグ木" : {
		"prefix": "LazySegmentTree_unrecursion",
		"body": [
			"template<class X,class M>",
			"struct LazySegmentTree{",
			"  using FX = function<X(X,X)>;",
			"  using FA = function<X(X,M)>;",
			"  using FM = function<M(M,M)>;",
			"  ll siz ;",
			"  FX fx; FA fa; FM fm;",
			"  const X ex;//Xの単位元",
			"  const M em;//Mの単位元",
			"  vector<X> tree;",
			"  vector<M> lazy;",
			"  ll height;",
			"  ",
			"  LazySegmentTree(ll n,FX _fx,FA _fa,FM _fm,X _ex,M _em)",
			"  :fx(_fx),fa(_fa),fm(_fm),ex(_ex),em(_em)",
			"  {",
			"    ll i = 0;",
			"    while((1 << i) < n){",
			"      i++;",
			"    }",
			"    tree.resize(1 << (i+1),_ex);",
			"    lazy.resize(1 << (i+1),_em);",
			"    siz = 1 << i;",
			"    height = i;",
			"  }",
			"  //treeの初期値を入れる,posは0indexed",
			"  void set(ll pos, X x){",
			"    tree[pos  + siz] = x;",
			"  }",
			" /*",
			"  siz = 4",
			"  tree:",
			"      1",
			"    2   3",
			"   4 5 6 7",
			"  lazyはトップダウン,treeはボトムアップで更新",
			"  */",
			"  //set()で入れた値でtreeを更新",
			"  void build(){",
			"    for(int i = siz -1;i >= 1;i--){",
			"      tree[i] = fx(tree[2*i],tree[2*i+1]);",
			"    }",
			"  }",
			" ",
			"  void tree_propagate(ll p){",
			"    tree[p]= fx(tree[2*p],tree[2*p+1]);",
			"  }",
			" ",
			"  void all_apply(ll p,M m){",
			"    tree[p] = fa(tree[p],m);",
			"    if(p < siz)lazy[p] = fm(lazy[p],m);",
			"  }",
			" ",
			"  void push(ll p){",
			"    if(lazy[p] == em)return ;",
			"    all_apply(2 * p,lazy[p]);",
			"    all_apply(2 * p+1,lazy[p]);",
			"    lazy[p] = em;",
			"  }",
			" ",
			"  X get(ll p){",
			"    p+= siz;",
			"    for(ll i = height;i >= 1;i--){",
			"      push(p >> i);",
			"    }",
			"    return tree[p];",
			"  }",
			" ",
			"  X query(ll l,ll r){",
			"    if(l == r)return ex;",
			"    l += siz;",
			"    r += siz;",
			" ",
			"    for (ll i = height;i >= 1;i--){",
			"      if(((l>> i) << i) != l)push(l>> i);",
			"      if(((r>>i) << i) != r)push((r-1)>> i);",
			"    }",
			" ",
			"    X sml = ex,smr = ex;",
			"    while(l < r){",
			"      if(l & 1)sml = fx(sml,tree[l++]);",
			"      if(r & 1)smr = fx(tree[--r],smr);",
			"      l >>= 1;",
			"      r >>= 1;",
			"    }",
			"    return fx(sml,smr);",
			" ",
			"  }",
			" ",
			"  void update(ll l,ll r, M m){",
			"    if(l == r)return ;",
			"    l+= siz;",
			"    r+= siz;",
			" ",
			"    for(ll i = height;i>= 1;i--){",
			"      if(((l>> i) << i) != l)push(l >> i);",
			"      if(((r>> i) << i) != r)push((r-1) >>i);",
			"    }",
			" ",
			"    {",
			"    ll tmpl = l,tmpr = r;",
			"    while(l < r){",
			"      if(l & 1) all_apply(l++,m);",
			"      if(r & 1) all_apply(--r,m);",
			"      l>>= 1;",
			"      r>>= 1;",
			"    }",
			"    l = tmpl;",
			"    r = tmpr;",
			"    }",
			" ",
			"    for(ll i = 1;i <= height;i++){",
			"      if(((l>>i)<< i) != l)tree_propagate(l>>i);",
			"      if(((r>>i)<< i) != r)tree_propagate((r-1) >> i);",
			"    }",
			"  }",
			"  X operator[](ll pos){",
			"    return get(pos);",
			"  }",
			" ",
			"};"
			
		],
		"description": "template for 非再帰遅延セグ木"
	},
	"SuffixArray" : {
		"prefix": "suffixarray",
		"body": [
			"vector<ll> suffixarray(string s){",
			"  ll n = s.size();",
			"  vector<ll> sa(n+1),rank(n+1),tmp(n+1);",
			"  for(ll i = 0;i <= n;i++){",
			"    sa[i] = i;",
			"    rank[i] = i < n ? s[i]:-1;//1文字目は文字コードでいい",
			"  }",
			"  for(ll k = 1;k <= n;k *= 2){",
			"    auto comp = [&](ll a,ll b)-> bool{",
			"      if(rank[a] != rank[b]){",
			"        return rank[a] < rank[b];",
			"      }else {",
			"        ll ra = a + k <= n ? rank[a+k]:-1;",
			"        ll rb = b + k <= n ? rank[b+k]:-1;",
			"        return ra < rb;",
			"      }",
			"    };",
			"    sort(sa.begin(),sa.end(),comp);",
			"    //tmpに次のランクを計算",
			"    tmp[sa[0]] = 0;",
			"    for(ll i = 1;i <= n;i++){",
			"      tmp[sa[i]] = tmp[sa[i-1]] + (comp(sa[i-1],sa[i]) ? 1:0);",
			"    }",
			"    for(ll i = 0;i <= n;i++){",
			"      rank[i] = tmp[i];",
			"    }",
			"  }",
			"  return sa;",
			"}"
			
		],
		"description": "template for SuffixArray"
	},
	"fix_setpercision" : {
		"prefix": "Fix_Setpercision",
		"body": [
			"std::fixed << std::setprecision(10) <<  ",
		],
		"description": "use for floating points"
	},
	"Eratosthenes" : {
		"prefix" : "Eratosthenes_hurui_Esutoratenesu",
		"body": [
			"//ref https://qiita.com/drken/items/3beb679e54266f20ab63#5-%E6%B4%BB%E7%94%A8%E4%BE%8B-2-%E3%83%A1%E3%83%93%E3%82%A6%E3%82%B9%E9%96%A2%E6%95%B0%E5%80%A4%E3%81%AE%E5%88%97%E6%8C%99",
"struct Eratosthenes{",
"  ll n;",
"  vector<bool> isprime;//素数ならtrue",
"  vector<ll> minfact;//xを割り切る一番小さい数",
"  vector<ll> mobius;// メビウス関数値",
"  /*",
"  メビウス関数u(x)とは",
"  u(1) = 1;",
"  xがある素数pで2回以上割り切れるとき、u(x) = 0;",
"  x = p1 * p2 * p3 * p4...pKと素因数分解できるときu(x) = (-1)^k ",
"  u(1)=1,u(2)=-1,u(3)=-1,u(4)=0,u(5)=-1,u(6)=1,u(7)=-1,u(8)=0,u(9)=0,u(10)=1",
"  */",
"  Eratosthenes(ll N){//O(NloglogN)",
"    n = N;",
"    isprime.resize(n+1,true);",
"    minfact.resize(n+1,-1);",
"    mobius.resize(n+1,1);",
"    isprime[0] = false;",
"    isprime[1] = false;",
"    minfact[1] = 1;",
"    for(ll p = 2;p <= n;p++){",
"      if(!isprime[p])continue;",
"      //pの情報を更新",
"      minfact[p] = p;",
"      mobius[p] = -1;",
"      for(ll q = p*2;q <= n;q+=p){",
"        isprime[q] = false;",
"        if(minfact[q] == -1)minfact[q] = p;",
"        if((q/p)%p==0)mobius[q]=0;//qはpで2回以上割れる",
"        else mobius[q] = -mobius[q];//反転",
"      }",
"    }",
"  }",
"",
"  bool is_prime(ll x){",
"    assert(x <= n);",
"    return isprime[x];",
"  }",
"",
"  //素因数分解(log(x))",
"  vector<pair<ll,ll>> soinsu_bunkai(ll x){",
"    vector<pair<ll,ll>> ret;",
"    while(x > 1){",
"      ll p = minfact[x];",
"      ll times = 0;//割り切れる回数",
"      while(minfact[x] == p){",
"        x/= p;",
"        times++;",
"      }",
"      ret.push_back({p,times});",
"    }",
"    return ret;",
"  }",
"",
"  //約数列挙 O(約数の個数)　n <= 10^9 のとき 高々1344",
"  vector<ll> yakusu_rekkyo(ll x){",
"    vector<ll> ret;",
"    ret.push_back(1);",
"    vector<pair<ll,ll>> pf = soinsu_bunkai(x);",
"    for(auto &p:pf){",
"      ll siz = ret.size();",
"      for(ll i = 0;i < siz;i++){",
"        ll v = 1;",
"        for(ll j = 0;j < p.second;j++){",
"          v *= p.first;",
"          ret.push_back(ret[i]*v);",
"        }",
"      }",
"    }",
"    return ret;",
"  }",
"};",
"",
"// 高速ゼータ変換",
"// 入力 f が in-place に更新されて、F になる",
"template<class T> void fast_zeta(vector<T> &f){",
"  ll n = f.size();",
"  Eratosthenes era(n);",
"  vector<bool> isprime = era.isprime;",
"  // 各素数 p 軸に対して",
"  // 大きい座標 (k * p) から小さい座標 (k) へと足し込む",
"  for(ll p = 2;p < n;p++){",
"    if(!isprime[p])continue;",
"    for(ll k = (n-1)/p;k >= 1;k--){",
"      f[k] += f[k * p];",
"    }",
"  }",
"} ",
"// 高速メビウス変換",
"// 入力 F が in-place に更新されて、f になる",
"template<class T> void fast_mobius(vector<T> &F){",
"  ll n = F.size();",
"  Eratosthenes era(n);",
"  vector<bool> isprime = era.isprime;",
"  // 各素数 p 軸に対して",
"  // 小さい座標 (k) から大きい座標 (k * p) を引いていく",
"  for(ll p = 2;p < n;p++){",
"    if(!isprime[p])continue;",
"    for(ll k = 1;k * p < n;k++){",
"      F[k] -= F[k * p];",
"    }",
"  }",
"}"
		],
		"description" :"エストラテネスのふるい"
	},
	"Miller-Rabin" : {
		"prefix" : "Miller-Rabin_mirra-rabin_sosuhantei",
		"body": [
			"//https://drken1215.hatenablog.com/entry/2023/05/23/233000",
			"// A^N mod M",
			"template<class T> T pow_mod(T A, T N, T M) {",
			"    T res = 1 % M;",
			"    A %= M;",
			"    while (N) {",
			"        if (N & 1) res = (res * A) % M;",
			"        A = (A * A) % M;",
			"        N >>= 1;",
			"    }",
			"    return res;",
			"}",
			"",
			"bool MillerRabin(long long N, vector<long long> A) {",
			"    long long s = 0, d = N - 1;",
			"    while (d % 2 == 0) {",
			"        ++s;",
			"        d >>= 1;",
			"    }",
			"    for (auto a : A) {",
			"        if (N <= a) return true;",
			"        long long t, x = pow_mod<__int128_t>(a, d, N);",
			"        if (x != 1) {",
			"            for (t = 0; t < s; ++t) {",
			"                if (x == N - 1) break;",
			"                x = __int128_t(x) * x % N;",
			"            }",
			"            if (t == s) return false;",
			"        }",
			"    }",
			"    return true;",
			"}",
			"",
			"bool is_prime(long long N) {",
			"    if (N <= 1) return false;",
			"    if (N == 2) return true;",
			"    if (N % 2 == 0) return false;",
			"    if (N < 4759123141LL)",
			"        return MillerRabin(N, {2, 7, 61});",
			"    else",
			"        return MillerRabin(N, {2, 325, 9375, 28178, 450775, 9780504, 1795265022});",
			"}"

		],
		"description" :"ミラーラビン素数判定法"
	},
	"Zobrist Hash" : {
		"prefix" : "Zobrist Hash",
		"body": [
			"//gloval定義 and 配列を受け取る版",
			"",
			"struct custom_hash {",
			"    static uint64_t splitmix64(uint64_t x) {",
			"        x += 0x9e3779b97f4a7c15;",
			"        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
			"        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
			"        return x ^ (x >> 31);",
			"    }",
			"",
			"    size_t operator() (uint64_t x) const {",
			"        static const uint64_t FIXED_RANDOM =    ",
			"            chrono::steady_clock::now().time_since_epoch().count();",
			"        return splitmix64(x + FIXED_RANDOM);",
			"    }",
			"} rng;",
			"",
			"// 要素の累積xor配列を返すイメージ",
			"// 配列aを受け取って Zobrist Hashを返す",
			"vector<uint64_t> hashing(vector<ll> a){",
			"  vector<uint64_t> hash(a.size() + 1, 0);//半開区間にする",
			"    set<long long> S;  // すでにあるかを確認する",
			"",
			"    for (int i = 0; i < (int)a.size(); ++i) {",
			"        long long x = a[i];",
			"",
			"        // すでに含まれている場合は何もしない",
			"        if (S.count(x)) {",
			"            hash[i + 1] = hash[i];",
			"            continue;",
			"        }",
			"        S.insert(x);",
			"        hash[i + 1] = hash[i] ^ rng(x);",
			"    }",
			"  return hash;",
			"}"

		],
		"description" :"Zobrist Hash"
	},
	"LowLink" : {
		"prefix" : "Lowlink",
		"body": [
			"struct Lowlink{",
			"  ll n;",
			"  vector<ll> ord;",
			"  vector<ll>low;",
			"  vector<ll>articulation,bridge;//atriculation 関節点,bridgeは橋になる辺の番号を格納 ",
			"  vector<vector<pll>> g;",
			"  vector<ll>found;",
			"  vector<ll> c;//二重辺連結分解で使用",
			"  ll m;//辺の数",
			" ",
			"  Lowlink(ll _n):n(_n),m(0){",
			"    ord.resize(n,INF);",
			"    low.resize(n);",
			"    g.resize(n);",
			"    found.resize(n);",
			"  }",
			" ",
			"  ll add_edge(ll u, ll v){",
			"    g[u].push_back({v,m});",
			"    g[v].push_back({u,m});",
			"    return m++;",
			"  }",
			" ",
			"  ll dfs(ll v,ll par, ll num){",
			"    ord[v] = num;",
			"    low[v] = num;",
			"    found[v] =1;",
			"    bool isa = false; //関節点かどうか",
			"    ll cnt = 0;//ｖが根のときに関節点かどうか判定に使用",
			"    for(auto &p:g[v]){",
			"      auto[to,id]  = p;",
			"      if(to == par){continue;}",
			"      if(found[to] != 0){",
			"        //発見済みだったから今見ている辺は後退辺",
			"        chmin(low[v],ord[to]);",
			"      }else{",
			"        //未発見",
			"        cnt++;",
			"        num = dfs(to,v,num+1);",
			"        if(par != -1 && low[to] >= ord[v]){",
			"          isa = true;",
			"        }",
			"        chmin(low[v],low[to]);",
			"        if(ord[v] < low[to]){",
			"          //子のlowが子で終わってたらbridge",
			"          bridge.push_back(id);",
			"        }",
			"      }",
			"    }",
			"    if(par == -1  && cnt >= 2)isa = true;",
			"    if(isa)articulation.push_back(v);//関節点だった",
			"    return num + 1;",
			"  }",
			"  //構築して連結成分数を返す ",
			"  ll build(){",
			"    ll k = 0;",
			"    ll cnt = 0;//シンプルに連結成分数",
			"    rep(i,n){",
			"      if(found[i] == 0){",
			"        k = dfs(i,-1,k);",
			"        cnt++;",
			"      }",
			"    }",
			"    return cnt; //シンプルに連結成分数を返しておく",
			"  }",
			" ",
			"  vector<vector<ll>> bc;",
			"  vector<ll> bc_id;",
			"  //二重頂点連結分解",
      "  //関節点で切る。辺の集合が得られる。",
			"  void bcc(){",
			"    bc_id = vector<ll>(m,-1);",
			"    vector<ll> used(n);",
			"    auto add = [&](ll id,ll num){",
			"      bc[num].push_back(id);",
			"      bc_id[id] = num;",
			"    };",
			"    auto dfs = [&](auto dfs,ll v,ll par,ll num)->void{",
			"      used[v] = 1;",
			"      for(auto &[to,id]:g[v]){",
			"        if(to == par){continue;}",
			"        if(used[to] == 0 ){",
			"          ll nownum = num;",
			"          if(low[to] >= ord[v]){",
			"            nownum = bc.size();",
			"            bc.push_back({});//新しくグループ作る",
			"          }",
			"          add(id,nownum);",
			"          dfs(dfs,to,v,nownum);",
			"        }else if(ord[to] < ord[v]){",
			"          add(id,num);//後退辺は同じグループ",
			"        }",
			"      }",
			"    };",
			"    rep(i,n){",
			"      if(used[i] == 0){",
			"        dfs(dfs,i,-1,-1);",
			"      }",
			"    }",
			"  }",
			"",
			"  ",
			"",
			"  //二重辺連結分解 build()した後",
			"  //cに各頂点がどのグループに属するか格納される",
      "  //橋を含まない頂点集合に分解する",
			"  ll two_edge_connect_component(){",
			"    //~~~~~~二重辺連結分解~~~~~~~~~~~",
			"    // 計算量 O(n+m)",
			"    c.resize(n,-1);",
			"    ll ccnt = 0;",
			"    rep(i,n){",
			"      if(c[i] == -1){",
			"        auto dfs2 = [&](auto dfs2, ll v,ll par,ll num)->ll{",
			"          if(par != -1 && ord[par] >= low[v]){",
			"            c[v] = c[par];",
			"          }else{",
			"            c[v] = num++;",
			"          }",
			"          for(auto &[to,id]:g[v]){",
			"            if(c[to] == -1){",
			"              num = dfs2(dfs2,to,v,num);",
			"            }",
			"          }",
			"          return num;",
			"        };",
			"        ccnt = dfs2(dfs2,i,-1,ccnt);",
			"      }",
			"    }",
			"    return ccnt;",
			"  }",
			"};",
		],
		"description" :"lowlink"
	},
	"Merge_sort_tree" : {
		"prefix": "Mergesorttree",
		"body": [
			"// ref https://hitonanode.github.io/cplib-cpp/segmenttree/merge_sort_tree.hpp",
			"//verify https://onlinejudge.u-aizu.ac.jp/solutions/problem/2426/review/8887581/T21140031/C++17",
			"//1indexed",
			"//静的配列aの[l,r)のうち値がx以下とかの個数をオンラインで求める",
			"template <class T>",
			"class MergeSortTree{",
			"  public:",
			"  ll n;",
			"  vector<vector<T>> tree;",
			"  ",
			"  MergeSortTree(const vector<T> &a){",
			"    n = a.size();",
			"    tree.resize(n * 2);",
			"    rep(i,n){",
			"      tree[n+i] = {a[i]};",
			"    }",
			"    for(ll i = n-1;i >= 1;i--){",
			"      merge(tree[i * 2].begin(),tree[i * 2].end(),tree[i * 2 + 1].begin(),tree[i * 2 + 1].end(),back_inserter(tree[i]));",
			"    }",
			"  }",
			"",
			"  //[l,r)でx未満",
			"  ll cntLess(ll l,ll r,T x){",
			"    l += n;",
			"    r += n;",
			"    ll ret = 0;",
			"    while(l < r){",
			"      if(l & 1){//演算してから足す",
			"        ret += lower_bound(all(tree[l]),x) - tree[l].begin();",
			"        l++;",
			"      }",
			"      if(r & 1){//演算する前に引く",
			"        r--;",
			"        ret += lower_bound(all(tree[r]),x) - tree[r].begin();",
			"      }",
			"      l>>=1;r>>=1;",
			"    }",
			"    return ret;",
			"  }",
			"",
			"  //x以下",
			"  ll cntLesseq(ll l,ll r,T x){",
			"    l += n;",
			"    r += n;",
			"    ll ret = 0;",
			"    while(l < r){",
			"      if(l & 1){//演算してから足す",
			"        ret += upper_bound(all(tree[l]),x) - tree[l].begin();l++;",
			"      }",
			"      if(r & 1){//演算する前に引く",
			"        r--;ret += upper_bound(all(tree[r]),x) - tree[r].begin();",
			"      }",
			"      l>>=1;r>>=1;",
			"    }",
			"    return ret;",
			"  }",
			"",
			"  //xより大きい",
			"  ll cntMore(ll l,ll r,T x){",
			"    ll total = max(0LL,min(r,n) - max(0LL,l));",
			"    return total - cntLesseq(l,r,x);",
			"  }",
			"",
			"  //x以上",
			"  ll cntMoreeq(ll l,ll r,T x){",
			"    ll total = max(0LL,min(r,n) - max(0LL,l));",
			"    return total - cntLess(l,r,x);",
			"  }",
			"};"

		],
		"description": "template for Merge Sort Tree"
	},
	"EularTour" : {
		"prefix": "EularTour",
		"body": [
			"struct EulerTour{",
			"  vector<ll> fa,la;//頂点vがDFS探索順で最初に現れた時間とその頂点を抜けた時間",
			"  vector<ll> depth;",
			"  vector<pair<ll,ll>> euler_tour;//dfsしたときに現れる頂点の(深さ、頂点番号)",
			"  EulerTour(){}",
			"  EulerTour(ll n,vector<vector<ll>> &g){",
			"    fa.resize(n);la.resize(n);",
			"    depth.resize(n,INF);",
			"    depth[0] = 0;",
			"    dfs_euler(g,0);",
			"  }",
			"",
			"  void dfs_euler(vector<vector<ll>> &g,ll v){",
			"    fa[v] = euler_tour.size();",
			"    euler_tour.push_back({depth[v],v});",
			"    for(auto &p:g[v]){",
			"      if(depth[p] == INF){",
			"        depth[p] = depth[v] + 1;",
			"        dfs_euler(g,p);",
			"        euler_tour.push_back({depth[v],v});",
			"      }",
			"    }",
			"    la[v] = euler_tour.size()-1;",
			"  }",
			"};"

		],
		"description": "template for Eular Tour"
	},
	"Auxiliary Tree" : {
		"prefix": "AuxiliaryTree_LCA",
		"body": [
			"//verify https://atcoder.jp/contests/typical90/submissions/50408180",
			"//1indexed",
			"template <class T>",
			"class SegmentTree{",
			"  public:",
			"  vector<T> tree;",
			"  ll siz = 0;",
			"  T e; //単位元 初期化に使われるやつ",
			"  function<T(T,T)> op;",
			"  function<T(T,T)> mapping = [](T a,T b){return b;};//更新に使用 デフォルトはただ更新",
			"",
			"  SegmentTree(){}",
			"  ",
			"  SegmentTree(ll n,T _e,function<T(T,T)> _op):e(_e),op(_op){",
			"    ll i = 0;",
			"    while((1 << i) < n ){",
			"      i++;",
			"    }",
			"    tree.resize(1<<(i+1),_e);",
			"    siz = 1 << i;",
			"  }",
			" ",
			"  //更新も工夫したいやつ",
			"  SegmentTree(ll n,T _e,function<T(T,T)> _op,function<T(T,T)>_mapping):e(_e),op(_op),mapping(_mapping){",
			"    ll i = 0;",
			"    while((1 << i) < n ){",
			"      i++;",
			"    }",
			"    tree.resize(1<<(i+1),_e);",
			"    siz = 1 << i;",
			"  }",
			"  ",
			"  void update(ll pos, T x){",
			"    pos = pos + siz;",
			"    tree[pos] = mapping(tree[pos],x);",
			"    while(pos>=2){",
			"      pos >>=1;",
			"      tree[pos] = op(tree[pos << 1|0], tree[pos<<1|1]);",
			"    }",
			"  }",
			"",
			"  //[l,r)",
			"  T query(ll l,ll r){",
			"    T retl = e,retr = e;",
			"    l += siz;",
			"    r += siz;",
			"    while(l < r){",
			"      if(l & 1)retl = op(retl,tree[l++]);//演算してから足す",
			"      if(r & 1)retr = op(tree[--r],retr);//演算する前に引く",
			"      l>>=1;r>>=1;",
			"    }",
			"    return op(retl,retr);",
			"  }",
			" ",
			"  T operator[](ll pos){",
			"    return tree[pos + siz];",
			"  }",
			"  ",
			"};",
      " ", 
			"struct EulerTour{",
			"  vector<ll> fa,la;//頂点vがDFS探索順で最初に現れた時間とその頂点を抜けた時間",
			"  vector<ll> depth;",
			"  vector<pair<ll,ll>> euler_tour;//dfsしたときに現れる頂点の(深さ、頂点番号)",
			"  EulerTour(){}",
			"  EulerTour(ll n,vector<vector<ll>> &g){",
			"    fa.resize(n);la.resize(n);",
			"    depth.resize(n,INF);",
			"    depth[0] = 0;",
			"    dfs_euler(g,0);",
			"  }",
			"",
			"  void dfs_euler(vector<vector<ll>> &g,ll v){",
			"    fa[v] = euler_tour.size();",
			"    euler_tour.push_back({depth[v],v});",
			"    for(auto &p:g[v]){",
			"      if(depth[p] == INF){",
			"        depth[p] = depth[v] + 1;",
			"        dfs_euler(g,p);",
			"        euler_tour.push_back({depth[v],v});",
			"      }",
			"    }",
			"    la[v] = euler_tour.size()-1;",
			"  }",
			"};",
			" ",
			"struct LCA{",
			"  SegmentTree<pair<ll,ll>> seg_euler;",
			"  EulerTour et;",
			"  LCA(){}",
			"  LCA(ll n,vector<vector<ll>> &g){//頂点数と隣接リスト",
			"    et = EulerTour(n,g);",
			"    ",
			"    seg_euler = SegmentTree<pair<ll,ll>>((ll)et.euler_tour.size(),{INF,INF},[](pair<ll,ll> a,pair<ll,ll> b){return min(a,b) == a ? a : b;});",
			"    seg_euler_setup(seg_euler);",
			"  }",
			"",
			"  //euler_tourの情報をSeg木に乗せるだけ",
			"  void seg_euler_setup(SegmentTree<pair<ll,ll>> &seg_euler){",
			"    ll siz = et.euler_tour.size();",
			"    rep(i,siz){",
			"      seg_euler.update(i,et.euler_tour[i]);",
			"    }",
			"  }",
			"",
			"  // x,yのLCA求める({深さ,頂点番号})",
			"  pair<ll,ll> query(ll x,ll y){",
			"    return seg_euler.query(min(et.fa[x],et.fa[y]),max(et.fa[x],et.fa[y])+1);",
			"  }",
			"};",
			" ",
			"struct AuxiliaryTree{//LCA木、共通祖先を維持したまま木を圧縮する",
			"  LCA lca;",
			"  ll n;",
			"",
			"  AuxiliaryTree(ll _n, vector<vector<ll>> &g):n(_n){",
			"    lca = LCA(_n,g);",
			"  }",
			"  //auxiliary tree の構築,頂点集合、隣接リスト、参照だから書き換わる",
			"  void make_auxiliary_tree(vector<ll> &vs,vector<vector<ll>> &retg){",
			"    assert((ll)retg.size() == n);",
			"    auto cmp_preorder = [&](ll x,ll y){",
			"      return lca.et.fa[x] < lca.et.fa[y]; ",
			"    };",
			"    sort(vs.begin(),vs.end(),cmp_preorder);",
			"    ll siz = vs.size();",
			"    rep(i,siz-1){",
			"      vs.push_back(lca.query(vs[i],vs[i+1]).second);",
			"    }",
			"    sort(vs.begin(),vs.end(),cmp_preorder);",
			"    vs.erase(unique(vs.begin(),vs.end()),vs.end());",
			"    stack<ll> st;",
			"    rep(i,vs.size()){",
			"      ll now = vs[i];",
			"      while(!st.empty() && lca.et.la[st.top()] < lca.et.fa[now]){",
			"        st.pop();",
			"      }",
			"      if(!st.empty()){",
			"        retg[st.top()].push_back(now);",
			"        retg[now].push_back(st.top());",
			"      }",
			"      st.push(now);",
			"    }",
			"  }",
			"};"
		],
		"description": "template for Auxiliary tree "
	},
	"3分探索" : {
		"prefix": "Sanbuntansaku",
		"body": [
			"//3分探索、初期値は閉区間の端でいい",
			"ll l = ;//左端閉",
			"ll r = ;//右端閉",
			"auto f = [&](ll m1,ll m2)->bool{",
			"  //m1のときの方がいい値かどうか",
			"};",
			"//最終的な答えは離散値ならl,l+1,rのいづれかにある",
			"while(abs(l-r) >2){",
			"  ll m1 = l + (r-l)/3;",
			"  ll m2 = r - (r-l)/3;",
			"  if(f(m1,m2)){",
			"    //m1のほうがいい値だった",
			"    r = m2;",
			"  }else{",
			"    l = m1;",
			"  }",
			"}"

		],
		"description": "template for 3分探索"
	},
	"Matrix" : {
		"prefix": "Matrix_Gyouretu",
		"body": [
			"//ref https://github.com/atcoder/live_library/blob/master/mat.cpp",
			"template<typename T>",
			"struct Matrix {",
			"  int h, w;",
			"  vector<vector<T>> d;",
			"  Matrix() {}",
			"  Matrix(int h, int w, T val=0): h(h), w(w), d(h, vector<T>(w,val)) {}",
			"  Matrix& unit() {",
			"    assert(h == w);",
			"    rep(i,h) d[i][i] = 1;",
			"    return *this;",
			"  }",
			"  const vector<T>& operator[](int i) const { return d[i];}",
			"  vector<T>& operator[](int i) { return d[i];}",
			"  Matrix operator*(const Matrix& a) const {",
			"    assert(w == a.h);",
			"    Matrix r(h, a.w);",
			"    rep(i,h)rep(k,w)rep(j,a.w) {",
			"      r[i][j] += d[i][k]*a[k][j];",
			"    }",
			"    return r;",
			"  }",
			"  Matrix pow(long long t) const {",
			"    assert(h == w);",
			"    if (!t) return Matrix(h,h).unit();",
			"    if (t == 1) return *this;",
			"    Matrix r = pow(t>>1);",
			"    r = r*r;",
			"    if (t&1) r = r*(*this);",
			"    return r;",
			"  }",
			"  /* mint only",
			"  mint det() {",
			"    assert(h == w);",
			"    mint res = 1;",
			"    rep(k,h) {",
			"      for (int i = k; i < h; ++i) {",
			"        if (d[i][k] == 0) continue;",
			"        if (i != k) {",
			"          swap(d[i],d[k]);",
			"          res = -res;",
			"        }",
			"      }",
			"      if (d[k][k] == 0) return 0;",
			"      res *= d[k][k];",
			"      mint inv = mint(1)/d[k][k];",
			"      rep(j,h) d[k][j] *= inv;",
			"      for (int i = k+1; i < h; ++i) {",
			"        mint c = d[i][k];",
			"        for (int j = k; j < h; ++j) d[i][j] -= d[k][j]*c;",
			"      }",
			"    }",
			"    return res;",
			"  }",
			"  //*/",
			"};"
			
		],
		"description": "template for Matrix"
	},
	"双対SegmentTree" : {
		"prefix": "SoutuiSegmentTree_Dual",
		"body": [
			"//双対セグ木",
"//verify https://onlinejudge.u-aizu.ac.jp/solutions/problem/DSL_2_D/review/8951597/T21140031/C++17",
"template<class M>",
"struct DualSegmentTree{",
"  using FM = function<M(M,M)>;",
"  ll siz ;",
"  FM fm;",
"  const M em;//Mの単位元",
"  vector<M> lazy;",
"  ll height;",
"  ",
"  DualSegmentTree(ll n,FM _fm,M _em):fm(_fm),em(_em)",
"  {",
"    ll i = 0;",
"    while((1 << i) < n){",
"      i++;",
"    }",
"    lazy.resize(1 << (i+1),_em);",
"    siz = 1 << i;",
"    height = i;",
"  }",
"",
"  void all_apply(ll p,M m){",
"    lazy[p] = fm(lazy[p],m);",
"  }",
"",
"  void push(ll p){",
"    if(lazy[p] == em)return ;",
"    all_apply(2 * p,lazy[p]);",
"    all_apply(2 * p+1,lazy[p]);",
"    lazy[p] = em;",
"  }",
"",
"  M get(ll p){",
"    p+= siz;",
"    for(ll i = height;i >= 1;i--){",
"      push(p >> i);",
"    }",
"    return lazy[p];",
"  }",
"",
"  M query(ll pos){",
"    return get(pos);",
"  }",
"",
"  void update(ll l,ll r, M m){",
"    if(l == r)return ;",
"    l+= siz;",
"    r+= siz;",
"",
"    for(ll i = height;i>= 1;i--){",
"      if(((l>> i) << i) != l)push(l >> i);",
"      if(((r>> i) << i) != r)push((r-1) >>i);",
"    }",
"    ",
"   ll tmpl = l,tmpr = r;",
"    while(l < r){",
"      if(l & 1) all_apply(l++,m);",
"      if(r & 1) all_apply(--r,m);",
"      l>>= 1;",
"      r>>= 1;",
"    }",
"    l = tmpl;",
"    r = tmpr;",
"  }",
"  M operator[](ll pos){",
"    return get(pos);",
"  }",
" ",
"};"

		],
		"description": "template for 双対セグ木"
	},
	"幾何_All" : {
		"prefix": "Kika_all_Geometry",
		"body": [
     "",
"//参考 https://github.com/saphmitchy/deliair-lib",
"// 型名",
"// R:Real, P:Point, L:Line, S:Segment, C:Circle, VP:vector<Point>",
"",
"#define X(p) real(p)",
"#define Y(p) imag(p)",
"",
"using R = ld;",
"using P = complex<R>;",
"using VP = vector<P>;",
"",
"//const R EPS = 1e-9; // ここは適宜調節する,いつものやつから消す",
"const R pi = acos(-1.0);",
"",
"int sgn(R a) {",
"    return (a < -EPS) ? -1 : (a > EPS) ? 1 : 0;",
"} // 符号関数",
"",
"bool eq(R a, R b) {//実数の一致判定",
"    return sgn(b - a) == 0;",
"}",
"",
"P operator*(P p, R d) {//ベクトルのd倍",
"    return P(X(p) * d, Y(p) * d);",
"}",
"",
"P operator/(P p, R d) {//ベクトルの1/d倍",
"    return p * (1 / d);",
"}",
"",
"istream &operator>>(istream &is, P &p) {",
"    // R a, b; // 入力が小数",
"    int a, b; // 入力が整数",
"    is >> a >> b;",
"    p = P(a, b);",
"    return is;",
"}",
"",
"ostream &operator<<(ostream &os, P p) {",
"    return os << X(p) << ' ' << Y(p);",
"}",
"",
"R getarg(P b,P a){//ベクトルbはベクトルaを何radian回転させる必要があるか",
"  assert(sgn(abs(a)) != 0);//長さが0はだめ",
"  return arg(b/a);",
"}",
"",
"bool cp_x(P p, P q) {//ベクトルの比較x軸で比較->y軸で比較",
"    if (!eq(X(p), X(q)))",
"        return X(p) < X(q);",
"    return Y(p) < Y(q);",
"}",
"",
"bool cp_y(P p, P q) {//ベクトルの比較y軸で比較->x軸で比較",
"    if (!eq(Y(p), Y(q)))",
"        return Y(p) < Y(q);",
"    return X(p) < X(q);",
"}",
"",
"struct L {//直線ab",
"    P a, b;",
"    L() {}",
"    L(P a, P b) : a(a), b(b) {}",
"",
"    // 入出力（必要なら）",
"    friend ostream &operator<<(ostream &os, L &l) {",
"        return os << l.a << ' ' << l.b;",
"    }",
"    friend istream &operator>>(istream &is, L &l) {",
"        return is >> l.a >> l.b;",
"    }",
"};",
"",
"struct S : L {//線分ab",
"    S() {}",
"    S(P a, P b) : L(a, b) {}",
"};",
"",
"struct C {//中心p 半径rの円",
"    P p;",
"    R r;",
"    C() {}",
"    C(P p, R r) : p(p), r(r) {}",
"};",
"",
"P rot(P p, R t) {//ベクトルの回転",
"    return p * P(cos(t), sin(t));",
"}",
"",
"//2つのベクトルの内積",
"R dot(P p, P q) {",
"    return X(p) * X(q) + Y(p) * Y(q);",
"}",
"",
"//2つのベクトルの外積",
"R det(P p, P q) {",
"    return X(p) * Y(q) - Y(p) * X(q);",
"}",
"",
"// https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_1_C&lang=jp",
"int ccw(P a, P b, P c) { // 線分 ab に対する c の位置関係 ",
"    b -= a, c -= a;//ベクトルab,ベクトルacにした",
"    if (sgn(det(b, c)) == 1)//外積右ねじ正",
"        return +1; // COUNTER_CLOCKWISE a,b,cが反時計回り",
"    if (sgn(det(b, c)) == -1)",
"        return -1; // CLOCKWISE",
"    if (dot(b, c) < 0.0)",
"        return +2; // ONLINE_BACK",
"    if (norm(b) < norm(c))",
"        return -2; // ONLINE_FRONT",
"    return 0;      // ON_SEGMENT",
"}",
"",
"bool para(L a, L b) { // 平行判定",
"    return eq(det(a.b - a.a, b.b - b.a), 0.0);",
"}",
"",
"bool orth(L a, L b) { // 垂直判定",
"    return eq(dot(a.b - a.a, b.b - b.a), 0.0);",
"}",
"",
"P proj(L l, P p) { // 垂線の足",
"    R t = dot(p - l.a, l.b - l.a) / norm(l.b - l.a);",
"    return l.a + (l.b - l.a) * t;",
"}",
"",
"// これいる？",
"// P proj(S s, P p) {",
"//     R t = dot(p - s.a, s.b - s.a) / norm(s.b - s.a);",
"//     return s.a + (s.b - s.a) * t;",
"// }",
"",
"P refl(L l, P p) { // 線対称の位置にある点",
"    return p + (proj(l, p) - p) * 2.0;",
"}",
"",
"bool inter(L l, P p) { // 交点を持つか判定",
"    return abs(ccw(l.a, l.b, p)) != 1;",
"}",
"",
"bool inter(S s, P p) {",
"    return ccw(s.a, s.b, p) == 0;",
"}",
"",
"bool inter(L l, L m) {",
"    if (!eq(det(l.b - l.a, m.b - m.a), 0.0))",
"        return true;",
"    return eq(det(l.b - l.a, m.b - l.a), 0.0);",
"}",
"",
"bool inter(L l, S s) {",
"    return sgn(det(l.b - l.a, s.a - l.a) * det(l.b - l.a, s.b - l.a)) <= 0;",
"}",
"",
"bool inter(S s, L l) {",
"    return inter(l, s);",
"}",
"",
"bool inter(S s, S t) {",
"    if (ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) > 0)",
"        return false;",
"    return ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;",
"}",
"",
"R dist(P p, P q) {",
"    return abs(q - p);",
"}",
"",
"R dist(L l, P p) {",
"    return abs(p - P(proj(l, p)));",
"}",
"",
"//R dist(S s, P p) {",
"//    P h = proj(s, p);",
"//    if (inter(s, h))",
"//        return abs(h - p);",
"//    return min(abs(s.a - p), abs(s.b - p));",
"//}",
"",
"R dist(S s, P p) {",
"    P h = proj(s, p);",
"    if(dot(p-s.a,s.b-s.a) <= 0) return abs(s.a-p);",
"    if(dot(p-s.b,s.a-s.b) <= 0) return abs(s.b-p);",
"    return abs(p - h);",
"}",
"",
"R dist(L l, L m) {",
"    return inter(l, m) ? 0.0 : dist(l, m.a);",
"}",
"",
"R dist(S s, S t) {",
"    if (inter(s, t))",
"        return 0.0;",
"    return min({dist(s, t.a), dist(s, t.b), dist(t, s.a), dist(t, s.b)});",
"}",
"",
"R dist(L l, S s) {",
"    if (inter(l, s))",
"        return 0.0;",
"    return min(dist(l, s.a), dist(l, s.b));",
"}",
"",
"R dist(S s, L l) {",
"    return dist(l, s);",
"}",
"",
"bool inter(C c, L l) {",
"    return sgn(c.r - dist(l, c.p)) >= 0;",
"}",
"",
"bool inter(C c, P p) {",
"    return eq(abs(p - c.p), c.r);",
"}",
"",
"// 共通接線の本数",
"// 交点なし:4",
"// 外接:3",
"// 2点で交わる:2",
"// 内接:1",
"// 一方がもう一方を内包:0",
"int inter(C c1, C c2) {",
"    if (c1.r < c2.r)",
"        swap(c1, c2);",
"    R d = abs(c1.p - c2.p);",
"    int a = sgn(d - c1.r - c2.r);",
"    if (a >= 0)",
"        return 3 + a;",
"    return 1 + sgn(d - c1.r + c2.r);",
"}",
"",
"VP crosspoint(L l, L m) {",
"    VP ret;",
"    if (!inter(l, m))",
"        return ret;",
"    R A = det(l.b - l.a, m.b - m.a);",
"    R B = det(l.b - l.a, l.b - m.a);",
"    if (eq(A, 0.0) && eq(B, 0.0)) {",
"        ret.emplace_back(m.a);",
"    } else {",
"        ret.emplace_back(m.a + (m.b - m.a) * B / A);",
"    }",
"    return ret;",
"}",
"",
"VP crosspoint(S s, S t) {",
"    return inter(s, t) ? crosspoint(L(s), L(t)) : VP();",
"}",
"",
"VP crosspoint(C c, L l) {//円と直線の交点",
"    P h = proj(l, c.p);",
"    P e = (l.b - l.a) / abs(l.b - l.a);",
"    VP ret;",
"    if (!inter(c, l))",
"        return ret;",
"    if (eq(dist(l, c.p), c.r)) {",
"        ret.emplace_back(h);",
"    } else {",
"        R b = sqrt(c.r * c.r - norm(h - c.p));",
"        ret.push_back(h + e * b), ret.push_back(h - e * b);",
"    }",
"    return ret;",
"}",
"",
"VP crosspoint(C c, S s) {//円と線分の交点",
"    P h = proj(s, c.p);",
"    P e = (s.b - s.a) / abs(s.b - s.a);",
"    VP ret;",
"    if (!inter(c, s))",
"        return ret;",
"    if (eq(dist(s, c.p), c.r)) {",
"        ret.emplace_back(h);",
"    } else {",
"        R b = sqrt(c.r * c.r - norm(h - c.p));",
"        if(ccw(s.a,s.b,h - e * b) == 0){//s.aに近い方から線分上なら追加する",
"          ret.push_back(h - e * b);",
"        }",
"        if(ccw(s.a,s.b,h + e * b)==0){",
"          ret.push_back(h + e * b);",
"        }",
"    }",
"    return ret;",
"}",
"",
"VP crosspoint(C c1, C c2) {//2つの円の交わる点",
"    R d = abs(c1.p - c2.p);",
"    R a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));",
"    R t = atan2(Y(c2.p) - Y(c1.p), X(c2.p) - X(c1.p));",
"    VP ret;",
"    if (inter(c1, c2) % 4 == 0) // 交わらないとき",
"        return ret;",
"    if (eq(a, 0.0)) {",
"        ret.emplace_back(P(c1.p + rot(P(c1.r, 0.0), t)));",
"    } else {",
"        P p1 = c1.p + rot(P(c1.r, 0.0), t + a);",
"        P p2 = c1.p + rot(P(c1.r, 0.0), t - a);",
"        ret.emplace_back(p1), ret.emplace_back(p2);",
"    }",
"    return ret;",
"}",
"",
"VP cut(VP p, L l, bool border = true) { // 直線が多角形に切り取られる区間",
"    int n = sz(p);",
"    p.emplace_back(p[0]), p.emplace_back(p[1]);",
"    VP ret;",
"    rep(i, n) {",
"        if (!eq(dist(l, p[i]), 0) && !eq(dist(l, p[i + 1]), 0)) {",
"            S s(p[i], p[i + 1]);",
"            if (eq(dist(l, s), 0)) {",
"                auto res = crosspoint(l, s);",
"                ret.emplace_back(res[0]);",
"            }",
"        }",
"        if (eq(dist(l, p[i + 1]), 0)) {",
"            if ((eq(dist(l, p[i]), 0) || eq(dist(l, p[i + 2]), 0)) && !border)",
"                continue;",
"            S s(p[i], p[i + 2]);",
"            if (eq(dist(l, s), 0))",
"                ret.emplace_back(p[i + 1]);",
"        }",
"    }",
"    return ret;",
"}",
"",
"VP rectangle(S s, R r) { // sを軸とした幅rの長方形",
"    P d = (s.a - s.b) * P(0, 1);",
"    d *= r / sqrt(norm(d));",
"    return VP{s.a + d, s.a - d, s.b - d, s.b + d};",
"}",
"",
"L vertical_bisector(P p, P q) { // 垂直二等分線",
"    L l;",
"    l.a = (p + q) * 0.5;",
"    l.b = l.a + rot(q - p, pi * 0.5);",
"    return l;",
"}",
"",
"L angle_bisector(P a,P b,P c){//角abcの二等分線(角bの２等分線)",
"  L l;",
"  l.a = b;",
"  R ang = atan2(Y(c-b),X(c-b)) - atan2(Y(a-b),X(a-b));//なす角",
"  ang/=2.0;",
"  l.b = l.a + rot(a-b,ang);",
"  return l;",
"}",
"",
"C Apollonius(P p, P q, R a, R b) { // アポロニウスの円",
"    P p1 = (p * b + q * a) / (a + b), p2 = (-p * b + q * a) / (a - b);",
"    C c;",
"    c.p = (p1 + p2) * 0.5;",
"    c.r = abs(p1 - p2) * 0.5;",
"    return c;",
"}",
"",
"R area(VP p) { // 多角形の面積",
"    R ret = 0.0;",
"    int n = sz(p);",
"    rep(i, n) ret += det(p[i], p[(i + 1) % n]);",
"    return abs(ret * 0.5);",
"}",
"",
"int in_polygon(VP p, P q) { // IN:2, ON:1, OUT:0",
"    int n = sz(p);",
"    int ret = 0;",
"    rep(i, n) {",
"        P a = p[i] - q, b = p[(i + 1) % n] - q;",
"        if (eq(det(a, b), 0.0) && sgn(dot(a, b)) <= 0)",
"            return 1;",
"        if (Y(a) > Y(b))",
"            swap(a, b);",
"        if (sgn(Y(a)) <= 0 && sgn(Y(b)) == 1 && sgn(det(a, b)) == 1)",
"            ret ^= 2;",
"    }",
"    return ret;",
"}",
"",
"VP tangent(C c, P p) { // 点 p を通る円 c の接線と c の接点",
"    return crosspoint(c, C(p, sqrt(norm(p - c.p) - c.r * c.r)));",
"}",
"",
"vector<L> tangent(C c1, C c2) { // 共通接線",
"    vector<L> ret;",
"    if (c1.r < c2.r)",
"        swap(c1, c2);",
"    R r = abs(c2.p - c1.p);",
"    if (eq(r, 0.0))",
"        return ret;",
"    P u = (c2.p - c1.p) / r;",
"    P v = rot(u, pi * 0.5);",
"    for (R s : {1.0, -1.0}) {",
"        R h = (c1.r + c2.r * s) / r;",
"        if (eq(abs(h), 1.0)) {",
"            ret.emplace_back(c1.p + u * c1.r, c1.p + (u + v) * c1.r);",
"        } else if (abs(h) < 1.0) {",
"            P uu = u * h, vv = v * sqrt(1.0 - h * h);",
"            ret.emplace_back(c1.p + (uu + vv) * c1.r, c2.p - (uu + vv) * c2.r * s);",
"            ret.emplace_back(c1.p + (uu - vv) * c1.r, c2.p - (uu - vv) * c2.r * s);",
"        }",
"    }",
"    return ret;",
"}",
"",
"VP convex_hull(VP p) { // 凸包",
"    sort(all(p), cp_x);",
"    p.erase(unique(all(p)), end(p));",
"    int n = sz(p), k = 0;",
"    if (n == 1)",
"        return p;",
"    VP ch(2 * n);",
"    for (int i = 0; i < n; ch[k++] = p[i++]) {",
"        while (k >= 2 && sgn(det(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1])) <= 0)",
"            k--;",
"    }",
"    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {",
"        while (k >= t && sgn(det(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1])) <= 0)",
"            k--;",
"    }",
"    ch.resize(k - 1);",
"    return ch;",
"}",
"",
"R closest_pair(VP p) { // 最近点対の距離",
"    if (sz(p) <= 1)",
"        return 1e18;",
"    sort(all(p), cp_x);",
"    VP memo(sz(p));",
"",
"    function<R(int, int)> rec = [&](int l, int r) {",
"        if (r - l <= 1)",
"            return R(1e18);",
"        int m = (l + r) >> 1;",
"        R x = X(p[m]);",
"        R ret = min(rec(l, m), rec(m, r));",
"        inplace_merge(p.begin() + l, p.begin() + m, p.begin() + r, cp_y);",
"        int cnt = 0;",
"        reps(i, l, r) {",
"            if (abs(X(p[i]) - x) >= ret)",
"                continue;",
"            rep(j, cnt) {",
"                P d = p[i] - memo[cnt - j - 1];",
"                if (Y(d) >= ret)",
"                    break;",
"                chmin(ret, abs(d));",
"            }",
"            memo[cnt++] = p[i];",
"        }",
"        return ret;",
"    };",
"",
"    return rec(0, sz(p));",
"}",
"",
"R farthest_pair(VP p) {//最遠点対の距離",
"  VP ps = convex_hull(p);",
"  ll n = ps.size();",
"  if(n == 2){//凸包が潰れてる",
"    return dist(ps[0],ps[1]);",
"  }",
"  ll i = 0,j = 0;",
"  rep(k,n){//x軸方向に最も遠い点対を求める",
"    if(cp_x(ps[k],ps[i]))i = k;",
"    if(cp_x(ps[j],ps[k]))j = k;",
"  }",
"  R ret = 0;",
"  ll si = i,sj = j;",
"  while(i != sj || j != si){//180度反転しきるまで",
"    ret = max(ret,dist(ps[i],ps[j]));",
"    if(det(ps[(i+1)%n] - ps[i],ps[(j+1)%n]-ps[j]) < 0){",
"      i = (i + 1) % n;",
"    }else{",
"      j = (j + 1) % n;",
"    }",
"  }",
"  return ret;",
"}",
"",
"// 原点, 点 a, 点 b とで囲まれる領域の面積 (三角形 ver と扇型 ver)",
"R calc_element(P a, P b, R cr,bool triangle){",
"  if(triangle)return det(a,b)/2;",
"  else{",
"    P tmp = b * (P(X(a),-Y(a)));",
"    R ang = atan2(Y(tmp),X(tmp));",
"    return cr * cr * ang/2;",
"  }",
"}",
"",
"// 円 C と、三角形 ((0, 0), ia, ib) との共通部分の面積",
"R common_area(C c, P ia,P ib){",
"  P a = ia - c.p , b = ib - c.p;",
"  if(eq(abs(a-b),0))return 0;",
"  bool isin_a = (sgn(c.r - abs(a))>= 0);",
"  bool isin_b = (sgn(c.r - abs(b))>= 0);",
"  if(isin_a && isin_b)return calc_element(a,b,c.r,true);//aもbも円の中",
"",
"  C oc(P(0,0),c.r);",
"  S seg(a,b);",
"  VP cr = crosspoint(oc,seg);",
"  if(cr.empty())return calc_element(a,b,c.r,false);",
"  P s = cr[0],t = cr.back();",
"  return calc_element(s,t,c.r,true) + calc_element(a,s,c.r,isin_a) + calc_element(t,b,c.r,isin_b);",
"",
"}",
"",
"",
"R common_area(C c, VP vp){// 円cと多角形の共通部分の面積",
"  R ret = 0;",
"  ll n = vp.size();",
"  rep(i,n){",
"    ret += common_area(c,vp[i],vp[(i+1)%n]);",
"  }",
"  return ret;",
"}",
"",
"R common_area(C p, C q) {// 円と円の共通部分の面積",
"    R d = abs(p.p - q.p);",
"    if (d >= p.r + q.r - EPS) return 0;",
"    else if (d <= abs(p.r - q.r) + EPS) return min(p.r, q.r) * min(p.r, q.r) * pi;",
"    R pcos = (p.r*p.r + d*d - q.r*q.r) / (p.r*d*2);",
"    R pang = acosl(pcos);",
"    R parea = p.r*p.r*pang - p.r*p.r*sin(pang*2)/2;",
"    R qcos = (q.r*q.r + d*d - p.r*p.r) / (q.r*d*2);",
"    R qang = acosl(qcos);",
"    R qarea = q.r*q.r*qang - q.r*q.r*sin(qang*2)/2;",
"    return parea + qarea;",
"}",
"",
"vector<VP> divisions(vector<L> lf, R lim = 1e9) {",
"    vector<L> ls;",
"    each(l, lf) {",
"        bool ok = true;",
"        each(m, ls) {",
"            if (para(l, m) & inter(l, m.a)) {",
"                ok = false;",
"                break;",
"            }",
"        }",
"        if (ok)",
"            ls.emplace_back(l);",
"    }",
"    VP lc{P(-lim, -lim), P(lim, -lim), P(lim, lim), P(-lim, lim)};",
"    rep(i, 4) ls.emplace_back(lc[i], lc[(i + 1) % 4]);",
"    int m = sz(ls);",
"    VP ps;",
"    vector<vector<int>> lp(m);",
"    rep(i, m) {",
"        reps(j, i + 1, m) {",
"            each(p, crosspoint(ls[i], ls[j])) {",
"                if (max(abs(X(p)), abs(Y(p))) < lim + EPS) {",
"                    lp[i].emplace_back(sz(ps)), lp[j].emplace_back(sz(ps));",
"                    ps.emplace_back(p);",
"                }",
"            }",
"        }",
"    }",
"    int n = sz(ps);",
"    vector<int> id(n, -1), to;",
"    vector<R> rg;",
"    vector<vector<pair<R, int>>> li(n);",
"    rep(i, m) {",
"        sort(all(lp[i]), [&ps](int a, int b) { return cp_x(ps[a], ps[b]); });",
"        vector<int> q;",
"        rep(j, sz(lp[i])) {",
"            int me = id[lp[i][j]], st = j;",
"            auto np = ps[lp[i][j]];",
"            while (j + 1 < sz(lp[i])) {",
"                if (abs(ps[lp[i][j + 1]] - np) < EPS) {",
"                    j++;",
"                    if (id[lp[i][j]] != -1)",
"                        me = id[lp[i][j]];",
"                } else",
"                    break;",
"            }",
"            if (me == -1)",
"                me = lp[i][st];",
"            reps(k, st, j + 1) id[lp[i][k]] = me;",
"            q.emplace_back(me);",
"        }",
"        rep(i, sz(q) - 1) {",
"            P d = ps[q[i + 1]] - ps[q[i]];",
"            R s = atan2(Y(d), X(d)), t = atan2(-Y(d), -X(d));",
"            int x = q[i], y = q[i + 1];",
"            li[x].emplace_back(s, sz(to));",
"            li[x].emplace_back(s + pi * 2, sz(to));",
"            to.emplace_back(y), rg.emplace_back(t);",
"            li[y].emplace_back(t, sz(to));",
"            li[y].emplace_back(t + pi * 2, sz(to));",
"            to.emplace_back(x), rg.emplace_back(s);",
"        }",
"    }",
"    rep(i, n) sort(all(li[i]));",
"    vector<bool> u(sz(to), false);",
"    vector<VP> ret;",
"    rep(i, n) {",
"        each(l, li[i]) {",
"            int ns = l.second;",
"            if (u[ns])",
"                continue;",
"            VP nv;",
"            int no = ns;",
"            bool ok = true;",
"            while (1) {",
"                if (sz(nv) > 1) {",
"                    P x = nv[sz(nv) - 2], y = nv[sz(nv) - 1], z = ps[to[no]];",
"                    int c = ccw(x, y, z);",
"                    if (c == 1)",
"                        ok = false;",
"                    if (c != -1)",
"                        nv.pop_back();",
"                }",
"                nv.emplace_back(ps[to[no]]);",
"                u[no] = true;",
"                no = upper_bound(all(li[to[no]]), pair(rg[no] + EPS, -1))->second;",
"                if (no == ns)",
"                    break;",
"            }",
"            if (ok)",
"                ret.emplace_back(nv);",
"        }",
"    }",
"    return ret;",
"}",
"",
"//ref https://github.com/drken1215/algorithm/blob/master/Geometry/arg_sort.cpp",
"//verify https://atcoder.jp/contests/abc139/submissions/me",
"//点列を偏角ソート",
"void arg_sort(VP &v){",
"  //原点=0,(pi,2pi] = -1  (0pi,pi] = 1",
"  auto sign = [&](const P &p){",
"    if(sgn(X(p)) == 0 && sgn(Y(p)) == 0){",
"      return 0;",
"    }else if(sgn(Y(p)) == -1 || (sgn(Y(p)) == 0 && sgn(X(p)) == 1)){",
"      return -1;",
"    }else{",
"      return 1;",
"    }",
"  };",
"  auto cp = [&](const P &p,const P &q){",
"    if(sign(p) != sign(q)){",
"      return sign(p) < sign(q);",
"    }else{//外積>0で判定",
"      //同じ向きにあるときは未定義、それぞれ決める",
"      return X(p) * Y(q) - Y(p) * X(q) > 0;",
"    }",
"  };",
"  sort(v.begin(),v.end(),cp);",
"}",
"",
     
		],
		"description": "幾何ライブラリ"
	},
  "SegmentTree2D" : {
		"prefix": "2DSegmentTree2D_nijigenn",
		"body": [
      "//verify(update & query) https://atcoder.jp/contests/abc106/submissions/52135955",
      "//verify(build & query) https://onlinejudge.u-aizu.ac.jp/solutions/problem/1068/review/9067005/T21140031/C++17",
      "//参考 https://drken1215.hatenablog.com/entry/2024/03/31/132815",
      "",
      "template<class T>",
      "class SegmentTree2D{",
      "  public:",
      "  vector<T> tree;",
      "  ll h,w;//配列のサイズに使う",
      "  ll hsiz,wsiz; ",
      "  T e; //単位元 初期化に使われるやつ",
      "  function<T(T,T)> op;",
      " ",
      "  SegmentTree2D(){}",
      "",
      "  SegmentTree2D(ll _h,ll _w,function<T(T,T)> _op,T _e){",
      "    init(_h,_w,_op,_e);",
      "  }",
      "",
      "  void init(ll _h,ll _w,function<T(T,T)> _op, T _e){",
      "    h = _h;w = _w;",
      "    op = _op;",
      "    e = _e;",
      "    ll i = 0;",
      "    while((1 << i) < h){i++;}",
      "    hsiz = 1 << i;",
      "",
      "    ll j = 0;",
      "    while((1 << j) < w){j++;}",
      "    wsiz = 1 << j;",
      "    tree.assign(hsiz * wsiz * 4,e);",
      "  }",
      "",
      "  ll id(ll y,ll x) const{",
      "    return y * 2 * wsiz + x;",
      "  }",
      "",
      "  void build(const vector<vector<T>> &v){",
      "    assert(h == (ll)v.size() && w == (ll)v[0].size());",
      "    rep(i,h){",
      "      rep(j,w){",
      "        tree[id(i + hsiz,j + wsiz)] = v[i][j];",
      "      }",
      "    }",
      "    for(ll j = wsiz;j < wsiz * 2;j++){",
      "      for(ll i = hsiz-1;i;i--){",
      "        tree[id(i,j)] = op(tree[id(i*2,j)],tree[id(i*2 +1,j)]);",
      "      }",
      "    }",
      "    for(ll i = 0;i <hsiz * 2;i++){",
      "      for(ll j = wsiz-1;j;j--){",
      "        tree[id(i,j)] = op(tree[id(i,j*2)],tree[id(i,j*2+1)]);",
      "      }",
      "    }",
      "  }",
      "",
      "  void update(ll y,ll x,T v){",
      "    assert(y >= 0 && y < h && x >= 0 && x < w);",
      "    y += hsiz;x += wsiz;",
      "    tree[id(y,x)] = v;",
      "    for(ll i = y >> 1;i;i >>= 1){",
      "      tree[id(i,x)] = op(tree[id(i * 2,x)],tree[id(i * 2 + 1,x)]);",
      "    }",
      "    for(;y;y >>= 1){",
      "      for(ll j = x >> 1;j;j>>= 1){",
      "        tree[id(y,j)] = op(tree[id(y,j * 2)],tree[id(y,j * 2 + 1)]);",
      "      }",
      "    }",
      "  }",
      "",
      "  T _query(ll y, ll xl,ll xr){",
      "    T ret = e;",
      "    while(xl < xr){",
      "      if(xl & 1)ret = op(ret,tree[id(y,xl++)]);",
      "      if(xr & 1)ret = op(tree[id(y,--xr)],ret);",
      "      xl >>= 1;xr >>= 1;",
      "    }",
      "    return ret;",
      "  }",
      "",
      "  T query(ll yl,ll yr,ll xl,ll xr){",
      "    assert(0 <= yl && yl <= yr && yr <= h);",
      "    assert(0 <= xl && xl <= xr && xr <= w);",
      "    T ret = e;",
      "    yl += hsiz; yr += hsiz; xl += wsiz; xr += wsiz;",
      "    while(yl < yr){",
      "      if(yl & 1)ret = op(ret,_query(yl++,xl,xr));",
      "      if(yr & 1)ret = op(_query(--yr,xl,xr),ret);",
      "      yl >>= 1;yr >>= 1;",
      "    }",
      "    return ret;",
      "  }",
      "",
      "  T operator () (ll y,ll x){",
      "    return tree[id(y + hsiz,x + wsiz)];",
      "  }",
      "};",
      
		],
		"description": "template for 2次元セグ木"
	},
	"重心分解" : {
		"prefix": "Jyushinbunnkai_CentroidDecomposition",
		"body": [
      "//verify https://atcoder.jp/contests/abc291/submissions/52202269",
      "struct CentroidDecomposition{",
      "  ll n;",
      "  vector<vector<ll>> g;",
      "  vector<ll> used;",
      "  //sz:重心分解後の最大部分木に含まれる頂点の数(自分を含める)",
      "  //parent:重心分解後の親の頂点",
      "  vector<ll> sz,parent;",
      "  CentroidDecomposition(ll _n,vector<vector<ll>> &_g):n(_n),g(_g){",
      "    used.resize(n);sz.resize(n);parent.resize(n);",
      "  }",
      "",
      "  //DFSして部分木のサイズを計算する",
      "  void calcsize(ll v, ll par){",
      "    sz[v] = 1;// szを重心分解するたびに繰り返し使うので1で一旦初期化",
      "    for(auto &p:g[v]){",
      "      if(p != par && used[p] == 0){",
      "        calcsize(p,v);",
      "        sz[v] += sz[p];",
      "      }",
      "    }",
      "  }",
      "",
      "  //今の頂点、元のグラフでの親、最後の重心、今重心を探してる部分木のサイズ",
      "  void _build(ll v,ll par,ll root,ll siz){",
      "    ll nv = -1;",
      "    ll maxtreesiz = 0;",
      "    for(auto &p:g[v]){",
      "      if(used[p] == 1 or p == par)continue;",
      "      if(chmax(maxtreesiz,sz[p])){",
      "        nv = p;",
      "      }",
      "    }",
      "    if(nv == -1){",
      "      //出る辺がなかった. o-o-... みたいなときで、この時親はすでに重心になっているはず",
      "      parent[v] = root;",
      "      return;",
      "    }",
      "    if(2 * maxtreesiz > siz){",
      "      //vは部分木の重心でないので部分木サイズの一番大きい隣接点に移動",
      "      _build(nv,v,root,siz);",
      "    }else{",
      "      //vが部分木の重心だった",
      "      used[v] = 1;",
      "      parent[v] = root;",
      "      for(auto &p:g[v]){",
      "        if(used[p] == 0){",
      "          calcsize(p,v);",
      "          _build(p,v,v,sz[p]);",
      "        }",
      "      }",
      "    }",
      "  }",
      "",
      "  void build(){",
      "    calcsize(0,-1);",
      "    _build(0,-1,-1,sz[0]);",
      "  }",
      "};",
      
		],
		"description": "template for 重心分解"
	},
  "全方位木DP" : {
		"prefix": "Zenhouikidp_KiDP",
		"body": [
"//ref https://github.com/drken1215/algorithm/blob/master/Tree/rerooting_with_edge.cpp",
"//verify https://atcoder.jp/contests/abc348/submissions/52401893",
"/*",
"    通常の木 DP において、頂点 v を根とする部分根付き木に関する再帰関数 dfs(v) について、",
" 　　　1. res = IDENTITY",
" 　　　2. 頂点 v の各子頂点 v2 (その辺を e とする) に対して：res = MERGE(res, ADDEDGE(e, rec(v2)))",
" 　　　3. return ADDNODE(v, res)",
" 　　というような更新を行うものとする。",
" 　　このような木 DP を全方位木 DP へと拡張する。",
"    using Graph = vector<vector<E>>;",
"    using GetIdFunc = function<ll(E)>;//Eから辺の行き先を取り出す",
"    using AddEdgeFunc = function<M(E, M)>;//情報を持ち上げるときにやりたい操作",
"    using MergeFunc = function<M(M, M)>;//情報のマージ",
"    using AddNodeFunc = function<M(ll, M)>;//頂点の情報で反映させたいもの",
"*/",
"template<class M,class E>",
"struct ReRooting{",
"  using Graph = vector<vector<E>>;",
"  using GetIdFunc = function<ll(E)>;//Eから辺の行き先を取り出す",
"  using AddEdgeFunc = function<M(E, M)>;//情報を持ち上げるときにやりたい操作",
"  using MergeFunc = function<M(M, M)>;//情報のマージ",
"  using AddNodeFunc = function<M(ll, M)>;//頂点の情報で反映させたいもの",
"",
"  Graph g;",
"  M e;",
"  GetIdFunc getid;",
"  AddEdgeFunc addedge;",
"  MergeFunc merge;",
"  AddNodeFunc addnode;",
"",
"  vector<vector<M>> dp;",
"",
"  ReRooting(){}",
"  ReRooting(const Graph &_g,const M &_e,const GetIdFunc &_getid,const AddEdgeFunc &_addedge,const MergeFunc &_merge,const AddNodeFunc &_addnode){",
"    g = _g;",
"    e = _e;",
"    getid = _getid;",
"    addedge = _addedge;",
"    merge = _merge;",
"    addnode = _addnode;",
"    build();",
"  }",
"",
"  //木DPする",
"  M rooting(ll v,ll par){",
"    M ret = e;",
"    dp[v].assign((ll)g[v].size(),e);",
"    rep(i,g[v].size()){",
"      ll nv = getid(g[v][i]);",
"      if(nv == par)continue;",
"      dp[v][i] = rooting(nv,v);",
"      ret = merge(ret,addedge(g[v][i],dp[v][i]));",
"    }",
"    return addnode(v,ret);",
"  }",
"",
"  void rerooting(ll v,ll par,M pval){",
"    rep(i,g[v].size()){",
"      ll nv = getid(g[v][i]);",
"      if(nv == par){",
"        dp[v][i] = pval;//親から来たやつ",
"        continue;",
"      }",
"    }",
"    //左右累積計算",
"    vector<M> left(g[v].size() + 1,e);",
"    vector<M> right(g[v].size() + 1,e);",
"    rep(i,g[v].size()){",
"      ll ri = (ll)g[v].size() -1- i;",
"      left[i+1] = merge(left[i],addedge(g[v][i],dp[v][i]));",
"      right[i+1] = merge(right[i],addedge(g[v][ri],dp[v][ri]));",
"    }",
"    rep(i,g[v].size()){",
"      ll nv = getid(g[v][i]);",
"      ll ri = (ll) g[v].size()- 1 - i;",
"      if(nv == par)continue;",
"      M npval = merge(left[i],right[ri]);",
"      rerooting(nv,v,addnode(v,npval));",
"    }",
"  }",
"",
"  void build(){",
"    dp.assign((ll)g.size(),vector<M>());",
"    ll root = 0;",
"    rooting(root,-1);  ",
"    ",
"    rerooting(root,-1,e);",
"  }",
"",
"  M get(ll x){",
"    M ret = e;",
"    rep(i,g[x].size()){",
"      ret = merge(ret,addedge(g[x][i],dp[x][i]));",
"    }",
"    return addnode(x,ret);",
"  }",
"};",  
		],
		"description": "template for 全方位木DP"
	},
  "Trie木" : {
		"prefix": "Trietree",
		"body": [
      "//ref https://algo-logic.info/trie-tree/#",
      "// verify https://atcoder.jp/contests/abc353/submissions/53574123",
      "//i番目のノードのrootからの距離がもしかしたら怪しいかも",
      "//char_size:文字の種類数、その0番目に当たる文字を base",
      "//例 : Trie<26,'a'>",
      "template<ll char_size,ll base>",
      "struct Trie{",
      "  struct Node{",
      "    vector<ll> next;//子のidx,存在しないなら-1",
      "    vector<ll> accept;//その頂点が末端となる文字列のid",
      "    ll c; //baseからの距離",
      "    ll common; //その頂点を何個の文字列が共有しているか",
      "    Node(ll _c){",
      "      c = _c;",
      "      common = 0;",
      "      next.assign(char_size,-1);",
      "    }",
      "  };",
      "",
      "  vector<Node> nodes;",
      "  ll root;",
      "",
      "  Trie(){",
      "    root = 0;",
      "    nodes.push_back(Node(root));",
      "  }",
      "",
      "  //文字列の挿入",
      "  void insert(const string &word,ll wordid){",
      "    ll nodeid = 0;",
      "    rep(i,word.size()){",
      "      ll c = (ll)(word[i] - base);",
      "      ll nextid = nodes[nodeid].next[c];",
      "      if(nextid == -1){//次の頂点がない",
      "        nextid = nodes.size();",
      "        nodes.push_back(Node(nodes[nodeid].c + 1)); //rootからの距離をNodeに持たせる.参考元から変更した",
      "        nodes[nodeid].next[c] = nextid;",
      "      }",
      "      nodes[nodeid].common++;",
      "      nodeid = nextid;",
      "    }",
      "    nodes[nodeid].common++;",
      "    nodes[nodeid].accept.push_back(wordid);",
      "  }",
      "  void insert(const string &word){",
      "    insert(word,nodes[0].common);",
      "  }",
      "",
      "  //wordがすでに存在するか",
      "  bool search(const string &word,bool prefix = false){",
      "    ll nodeid = 0;",
      "    rep(i,word.size()){",
      "      ll c = (ll)(word[i] - base);",
      "      ll nextid = nodes[nodeid].next[c];",
      "      if(nextid == -1){//次の頂点がない",
      "        return false;",
      "      }",
      "      nodeid = nextid;",
      "    }",
      "    if(prefix){",
      "      return true;",
      "    }else{",
      "      return nodes[nodeid].accept.size() > 0;",
      "    }",
      "  }",
      "  bool start_with(const string &prefix){",
      "    return search(prefix,true);",
      "  }",
      "",
      "  //挿入した数",
      "  ll count() const {",
      "    return nodes[0].common;",
      "  }",
      "",
      "  // Trie木のノードの数",
      "  ll size() const {",
      "    return nodes.size();",
      "  }",
      "",
      "};",
      
		],
		"description": "template for Trie木"
	},
  "最小費用流" : {
		"prefix": "MincostFlow_Saisyouhiyouryuu",
		"body": [
"//参考: 蟻本P.203",
"//verify https://onlinejudge.u-aizu.ac.jp/solutions/problem/GRL_6_B/review/9361927/T21140031/C++17",
"struct Edge {",
" ll to,cap,cost,rev;",
"};",
"struct MincostFlow{",
"  ll siz = 0;//頂点数",
"  vector<vector<Edge>> G;",
"  vector<ll> h;//ポテンシャル",
"  vector<ll> dist;//最短距離",
"  vector<ll> prevv,preve;//直前の頂点と辺",
"  using P = pair<ll,ll>;",
"  MincostFlow(ll n){",
"    siz = n;",
"    G.resize(siz);h.resize(siz);dist.resize(siz);",
"    prevv.resize(siz);preve.resize(siz);",
"  }",
"",
"  //fromからtoへ容量cap,コストcostの辺を追加",
"  void add_edge(ll from,ll to, ll cap,ll cost){",
"    G[from].push_back((Edge){to,cap,cost,(ll)G[to].size()});",
"    G[to].push_back((Edge){from,0,-cost,(ll)G[from].size()-1});",
"  }",
"",
"  //sからtへの流量fの最小費用流",
"  //流せないなら-1",
"  //{流せた流量,かかったコスト}を返す",
"  P min_cost_flow(ll s,ll t,ll f){",
"    ll retf = 0,retcost = 0;//流れた流量とかかったコスト",
"    h.assign(siz,0LL);",
"    while(f > 0){//ダイクストラでhを更新",
"      priority_queue<P,vector<P>,greater<P>> pq;",
"      dist.assign(siz,INF);",
"      dist[s] = 0;",
"      pq.push({0,s});",
"      while(!pq.empty()){",
"        P now = pq.top();pq.pop();",
"        ll v = now.second;",
"        if(dist[v] < now.first) continue;",
"        for(ll i = 0;i < (ll)G[v].size();i++){",
"          Edge &e = G[v][i];",
"          if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){",
"            dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];",
"            prevv[e.to] = v;",
"            preve[e.to] = i;",
"            pq.push({dist[e.to],e.to});",
"          }",
"        }",
"      }",
"      if(dist[t] == INF){//流せなかった",
"        return {0,-1};",
"      }",
"      for(ll i = 0;i < siz;i++)h[i] += dist[i];",
"      //s->tの最短経路に沿って目一杯流す",
"      ll d = f;",
"      for(ll v = t;v != s;v = prevv[v]){",
"        d = min(d,G[prevv[v]][preve[v]].cap);",
"      }",
"      f -= d;",
"      retf += d;",
"      retcost += d * h[t];",
"      for(ll v = t;v != s;v = prevv[v]){",
"        Edge &e = G[prevv[v]][preve[v]];",
"        e.cap -= d;",
"        G[v][e.rev].cap += d;",
"      }",
"    } ",
"    return {retf,retcost};",
"  }",
"};",
		],
		"description": "template for "
	},
  "2DBIT" : {
		"prefix": "2DBIT_nijigen",
		"body": [
"//verify https://atcoder.jp/contests/abc130/submissions/56682512",
"//ref https://algo-logic.info/binary-indexed-tree/",
"template <typename T>",
"struct BIT2D {",
"    int H, W;",
"    vector<vector<T>> bit;  // データの格納先",
"    BIT2D(int H_, int W_) { init(H_, W_); }",
"    void init(int H_, int W_) {",
"        H = H_ + 1;",
"        W = W_ + 1;",
"        bit.assign(H, vector<T>(W, 0));",
"    }",
"    //(h-1,w-1)にxを加算",
"    void add(int h, int w, T x) {",
"        h++;w++;",
"        for (int i = h; i < H; i += (i & -i)) {",
"            for (int j = w; j < W; j += (j & -j)) {",
"                bit[i][j] += x;",
"            }",
"        }",
"    }",
"    // 0<=i<h かつ 0<=j<w",
"    T sum(int h, int w) {",
"        T s(0);",
"        for (int i = h; i > 0; i -= (i & -i)) {",
"            for (int j = w; j > 0; j -= (j & -j)) {",
"                s += bit[i][j];",
"            }",
"        }",
"        return s;",
"    }",
"    // h1<=i<h2 かつ w1<=j<w2",
"    T query(int h1, int h2, int w1, int w2) {",
"      return sum(h2, w2 ) - sum(h2 , w1 ) - sum(h1 , w2 ) + sum(h1 , w1 );",
"    }",
"};",
		],
		"description": "template for "
	},
  "HLD" : {
		"prefix": "HLD",
		"body": [
"//verify https://judge.yosupo.jp/submission/232848",
"//20240909 decideheavy内で親が先頭に来る問題を修正",
"//reverify https://atcoder.jp/contests/past202004-open/submissions/57609802",
"//ref https://atcoder.jp/contests/abc269/editorial/4838",
"//https://qiita.com/Pro_ktmr/items/4e1e051ea0561772afa3",
"struct HLD{",
"  ll n;",
"  vector<vector<ll>> g;",
"  vector<ll> par;//親の頂点番号",
"  vector<ll> sub;//頂点iの部分木サイズ",
"  vector<ll>head;//頂点iを含むheavy pathの頂点",
"  vector<ll> la;//頂点iの部分木に含まれる最後のindex",
"  vector<ll>plc;//頂点iがhld列の何番目に現れるか",
"  vector<ll>order;//HLDした頂点列",
"  HLD(ll _n,vector<vector<ll>> &_g,ll root = 0){",
"    n = _n;",
"    g = _g;",
"    n = g.size();",
"    par.resize(n,-1);sub.resize(n,-1);",
"    head.resize(n,-1);la.resize(n,-1);",
"    plc.resize(n,-1);",
"    decide_heavy(root);",
"    head[root] = root;",
"    makehld(root);",
"  }",
"  //部分木サイズを計算しHeavyedge,Lightedgeに分解する",
"  ll decide_heavy(ll v){",
"    sub[v] = 1;",
"    for(auto &to:g[v])if(par[v]!=to){",
"      par[to] = v;",
"      sub[v] += decide_heavy(to);",
"      //g[v]の先頭がvの親なら強制swap",
"      //今見てる部分木がg[v][0]を根とする部分木より大きいならswap",
"      if(g[v][0] == par[v] || sub[to] > sub[g[v][0]])swap(to,g[v][0]);",
"    }",
"    return sub[v];",
"  }",
" ",
"  void makehld(ll v){",
"    plc[v] = order.size();",
"    order.push_back(v);",
"    for(auto &to:g[v])if(par[v]!=to){",
"      if(to == g[v][0]){",
"        head[to] = head[v];",
"      }else{",
"        head[to] = to;",
"      }",
"      makehld(to);",
"    }",
"    la[v] = (ll)order.size()-1;",
"  }",
"  //u-vパスを結ぶheavy path列を返す",
"  //辺についてのクエリを処理する際は最後注意するverify: https://atcoder.jp/contests/past202004-open/submissions/57609802",
"  vector<pair<ll,ll>> query(ll u,ll v,bool is_edge_query = false){",
"    vector<pair<ll,ll>> ret;",
"    while(head[u] != head[v]){",
"      if(plc[u] > plc[v])swap(u,v);",
"      //vを前に持ってくる",
"      ret.push_back({plc[head[v]],plc[v]});",
"      v = par[head[v]];",
"    }",
"    ret.push_back({min(plc[u],plc[v]) + is_edge_query,max(plc[u],plc[v])});",
"    return ret;",
"  }",
" ",
"};",

		],
		"description": "template for Heavy Light Decomposition"
	},
  "GridBFS" : {
		"prefix": "GridBFS",
		"body": [
"vvll find(h,vll(w,INF));",
"queue<pll> que;",
"find[0][0] = 0;",
"que.push({0,0});",
"while(!que.empty()){",
"  auto[nowy,nowx] = que.front();",
"  que.pop();",
"  rep(p,4){",
"    ll ny = nowy + _ta[p];",
"    ll nx = nowx + _yo[p];",
"    if(isin(ny,nx,h,w) && find[ny][nx] > find[nowy][nowx] + 1){",
"      find[ny][nx] = find[nowy][nowx]+1;",
"      que.push({ny,nx});",
"    }",
"  }",
"}",
		],
		"description": "template for GridBFS"
	},
  "RBST" : {
		"prefix": "Heikounibunki_RBST",
		"body": [
"//ref https://github.com/drken1215/algorithm/blob/master/DataStructureSegment/randomized_binary_search_tree.cpp",
"// RBST",
"typedef long long VAL;",
"const VAL SUM_UNITY = 0;",
"struct RBST {",
" unsigned int randInt() {",
"   static unsigned int tx = 123456789, ty = 362436069, tz = 521288629, tw = 88675123;",
"   unsigned int tt = (tx ^ (tx << 11));",
"   tx = ty; ty = tz; tz = tw;",
"   return (tw = (tw ^ (tw >> 19)) ^ (tt ^ (tt >> 8)));",
" }",
"",
" struct NODE {",
"   NODE *left, *right;",
"   VAL val;                        // the value of the node",
"   int size;                       // the size of the subtree ",
"   VAL sum;                        // the value-sum of the subtree",
"",
"   NODE() : val(SUM_UNITY), size(1), sum(SUM_UNITY) {",
"     left = right = NULL;",
"   }",
"",
"   NODE(VAL v) : val(v), size(1), sum(v) {",
"     left = right = NULL;",
"   }",
"",
"   /* additional update */",
"   inline void update() {",
"",
"   }",
"",
"   /* additional lazy-propagation */",
"   inline void push() {",
"",
"     /* ex: reverse */",
"     /*",
"     if (this->rev) {",
"     swap(this->left, this->right);",
"     if (this->left) this->left->rev ^= true;",
"     if (this->right) this->right->rev ^= true;",
"     this->rev = false;",
"     }",
"     */",
"   }",
" };",
"",
"",
" ///////////////////////",
" // root",
" ///////////////////////",
"",
" NODE* root;",
" RBST() : root(NULL) { }",
" RBST(NODE* node) : root(node) { }",
"",
"",
" ///////////////////////",
" // basic operations",
" ///////////////////////",
"",
" /* size */",
" inline int size(NODE *node) {",
"   return !node ? 0 : node->size;",
" }",
" inline int size() {",
"   return this->size(this->root);",
" }",
"",
" /* sum */",
" inline VAL sum(NODE *node) {",
"   return !node ? SUM_UNITY : node->sum;",
" }",
" inline VAL sum() {",
"   return this->sum(this->root);",
" }",
"",
" /* update, push */",
" inline NODE* update(NODE *node) {",
"   node->size = size(node->left) + size(node->right) + 1;",
"   node->sum = sum(node->left) + sum(node->right) + node->val;",
"   node->update();",
"   return node;",
" }",
"",
" inline void push(NODE *node) {",
"   if (!node) return;",
"   node->push();",
" }",
"",
" /* lower_bound */",
" inline int lowerBound(NODE *node, VAL val) {",
"   push(node);",
"   if (!node) return 0;",
"   if (val <= node->val) return lowerBound(node->left, val);",
"   else return size(node->left) + lowerBound(node->right, val) + 1;",
" }",
" inline int lowerBound(VAL val) {",
"   return this->lowerBound(this->root, val);",
" }",
"",
" /* upper_bound */",
" inline int upperBound(NODE *node, VAL val) {",
"   push(node);",
"   if (!node) return 0;",
"   if (val >= node->val) return size(node->left) + upperBound(node->right, val) + 1;",
"   else return upperBound(node->left, val);",
" }",
" inline int upperBound(VAL val) {",
"   return this->upperBound(this->root, val);",
" }",
"",
" /* count */",
" inline int count(VAL val) {",
"   return upperBound(val) - lowerBound(val);",
" }",
"",
" /* get --- k: 0-index */",
" inline VAL get(NODE *node, int k) {",
"   push(node);",
"   if (!node) return -1;",
"   if (k == size(node->left)) return node->val;",
"   if (k < size(node->left)) return get(node->left, k);",
"   else return get(node->right, k - size(node->left) - 1);",
" }",
" inline VAL get(int k) {",
"   return get(this->root, k);",
" }",
"",
"",
" ///////////////////////",
" // merge-split",
" ///////////////////////",
"",
" NODE* merge(NODE *left, NODE *right) {",
"   push(left);",
"   push(right);",
"   if (!left || !right) {",
"     if (left) return left;",
"     else return right;",
"   }",
"   if (randInt() % (left->size + right->size) < left->size) {",
"     left->right = merge(left->right, right);",
"     return update(left);",
"   }",
"   else {",
"     right->left = merge(left, right->left);",
"     return update(right);",
"   }",
" }",
" void merge(RBST add) {",
"   this->root = this->merge(this->root, add.root);",
" }",
" pair<NODE*, NODE*> split(NODE* node, int k) { // [0, k), [k, n)",
"   push(node);",
"   if (!node) return make_pair(node, node);",
"   if (k <= size(node->left)) {",
"     pair<NODE*, NODE*> sub = split(node->left, k);",
"     node->left = sub.second;",
"     return make_pair(sub.first, update(node));",
"   }",
"   else {",
"     pair<NODE*, NODE*> sub = split(node->right, k - size(node->left) - 1);",
"     node->right = sub.first;",
"     return make_pair(update(node), sub.second);",
"   }",
" }",
" RBST split(int k) {",
"   pair<NODE*, NODE*> sub = split(this->root, k);",
"   this->root = sub.first;",
"   return RBST(sub.second);",
" }",
"",
"",
" ///////////////////////",
" // insert-erase",
" ///////////////////////",
"",
" void insert(const VAL val) {",
"   pair<NODE*, NODE*> sub = this->split(this->root, this->lowerBound(val));",
"   this->root = this->merge(this->merge(sub.first, new NODE(val)), sub.second);",
" }",
"",
" void erase(const VAL val) {",
"   if (!this->count(val)) return;",
"   pair<NODE*, NODE*> sub = this->split(this->root, this->lowerBound(val));",
"   this->root = this->merge(sub.first, this->split(sub.second, 1).second);",
" }",
"",
"",
" ///////////////////////",
" // debug",
" ///////////////////////",
"",
" void print(NODE *node) {",
"   if (!node) return;",
"   push(node);",
"   print(node->left);",
"   cout << node->val << \" \";",
"   print(node->right);",
" }",
" void print() {",
"   cout << \"{\";",
"   print(this->root);",
"   cout << \"}\" << endl;",
" }",
"};",
		],
		"description": "template for平衡二分探索木 "
	},
  "動的セグ木" : {
		"prefix": "DynamicSegmentTree_Douteki",
		"body": [
"// Dynamic Segment Tree",
"//verify https://atcoder.jp/contests/abc403/submissions/65613814",
"//ref1 https://tjkendev.github.io/procon-library/cpp/range_query/dynamic_segment_tree.html  updateが変かも？",
"//ref2 https://lorent-kyopro.hatenablog.com/entry/2021/03/12/025644 update部分を参考にした",
"template<class T>",
"struct DynamicSegmentTree {",
"  int n, siz;",
"  T e ;",
"  function<T(T,T)> op;",
"",
"  struct Node {",
"    Node *left, *right;",
"    T v;",
"",
"    Node(const T& _e) : left(nullptr), right(nullptr), v(_e) {}",
"    ~Node() {",
"      delete left;",
"      delete right;",
"    }",
"  };",
"",
"  Node *root;",
"",
"  DynamicSegmentTree(int _n) : n(_n) {",
"    siz = 1;",
"    while(siz < n) siz <<= 1;",
"    root = new Node(e);",
"  }",
"  DynamicSegmentTree(int _n,T _e,function<T(T,T)>_op):n(_n),e(_e),op(_op){",
"    siz = 1;",
"    while(siz < n) siz <<= 1;",
"    root = new Node(e);",
"  }",
"  ~DynamicSegmentTree() {",
"    delete root; root = nullptr;",
"  }",
" ",
"  void update(Node*& n, int a, int b, int p, T x) {",
"    // そのノードがまだ作られていなかったら作る",
"    if (!n) n = new Node(e);",
"    // 区間幅が 1、つまりセグ木の葉にたどり着いたら値を更新",
"    if (b - a == 1) {",
"      n->v = x;",
"      return;",
"    }",
"    // それ以外の場合は左か右の子に進む",
"    int c = (a + b) >> 1;",
"    if (p < c) update(n->left, a, c, p, x);",
"    else update(n->right, c, b, p, x);",
"    // ノードの値の更新（左右の子が作られていない可能性があることに注意）",
"    n->v = e;",
"    if (n->left) n->v = op(n->left->v,n->v);",
"    if (n->right) n->v = op(n->v,n->right->v);",
"  }",
"",
"  void update(int p,T x){",
"    update(root,0,siz,p,x);",
"  }",
" ",
"  T query(int a, int b) {",
"    return query(a, b, root, 0, siz);",
"  }",
"",
"  T query(int a, int b, Node *n, int l, int r) {",
"    if(r <= a || b <= l) {",
"      return e;",
"    }",
"    if(a <= l && r <= b) {",
"      return n->v;",
"    }",
"  ",
"    T lv = n->left ? query(a, b, n->left, l, (l + r) >> 1) : e;",
"    T rv = n->right ? query(a, b, n->right, (l + r) >> 1, r) : e;",
"    return op(lv,rv);",
"  }",
"};",

		],
		"description": "template for DynamicSegmentTree"
	},
  "HLD強化版" : {
		"prefix": "HLD_LCA_Eular_Tour",
		"body": [
"template <typename T>",
"struct Edge {",
"  int from; int to;",
"  T cost;",
"",
"  // default constructor",
"  Edge () : from(-1), to(-1), cost(T(0)) {}",
"",
"  Edge(int _from, int _to, T _cost) : from(_from), to(_to), cost(_cost) {}",
"",
"  // unweighted",
"  Edge(int _from, int _to) : from(_from), to(_to), cost(T(1)) {}",
"",
"  bool operator==(const Edge& rhs) const {",
"    return from == rhs.from && to == rhs.to && cost == rhs.cost;",
"  }",
"",
"  bool operator<(const Edge& rhs) const {",
"    return cost < rhs.cost;",
"  }",
"  ",
"  bool operator>(const Edge& rhs) const {",
"    return cost > rhs.cost;",
"  }",
"",
"};",
"",
"",
"template <typename T>",
"struct Graph : std::vector<std::vector<Edge<T>>> {",
"",
"  using std::vector<std::vector<Edge<T>>>::vector; // inherit constructors",
"",
"  void add_edge(int i, Edge<T> e) {",
"    (*this)[i].push_back(e);",
"  }",
"",
"  void add_edge(Edge<T> e) {",
"    (*this)[e.from].push_back(e);",
"  }",
"",
"  // weighted",
"  void add_edge(int _from, int _to, T _cost) {",
"    (*this)[_from].push_back(Edge(_from, _to, _cost));",
"  }",
"",
"  // unweighted",
"  void add_edge(int _from, int _to) {",
"    (*this)[_from].push_back(Edge(_from, _to, T(1)));",
"  }",
"",
"};",
"",
"// cf : https://ngtkana.hatenablog.com/entry/2024/06/24/200138",
"struct Interval {",
"  // top_id : interval のもっとも根に近い頂点のid",
"  // bottom_id : interval のもっとも葉に近い頂点のid",
"  // last : LCAを含む interval であるかどうか",
"  // reverse : from → to と top → bottomが逆向きかどうか",
"  int top_id, bottom_id;",
"  bool last;",
"  bool reverse;",
"",
"  Interval(int _top_id, int _bottom_id, bool _last, bool _reverse) : top_id(_top_id), bottom_id(_bottom_id), last(_last), reverse(_reverse) {",
"",
"  }",
"};",
"",
"using Path = std::vector<Interval>;",
"",
"/*",
"木をいくつかのパスに分けるアルゴリズム。",
"うまくDFSしてパスに分けると、同じパスの中でidが連続するので、一つのパスの中ではセグメント木などの列に対してのアルゴリズムが使えるようになる。",
"",
"頂点属性の問題はかんたん。",
"辺属性の問題は、辺の子側の頂点にその情報をもたせて管理するといい。 そのときはLCAに注意する。",
"*/",
"//usage : https://harui-i.github.io/library/graph/tree/heavy_light_decomposition.hpp",
"struct HLD {",
"private:",
"  bool is_built = false;",
"public:",
"  //vector<vector<int>>children;",
"  std::vector<int> parent;",
"  std::vector<int> id; // id[v] := 頂点vがdfs順で何番目にあるか。 HLDで分割したパスの中では、深さが浅い方から深い方へidが連続して増えていく。",
"  std::vector<int> id2;",
"  std::vector<int> head; // head[v] := 頂点vが所属する分割されたパスの、一番根に近い頂点。",
"  std::vector<int> depth; // depth[v] := 頂点vの深さ",
"  Graph<int> graph;",
"",
"  HLD (int N) : parent(std::vector<int>(N, -1)), id(std::vector<int>(N)), id2(std::vector<int>(N)), head(std::vector<int>(N)), depth(std::vector<int>(N)), graph(N) {}",
"",
"  void build(int root=0) {",
"    dfs_sz(root);",
"    int k = 0; dfs_hld(root, k);",
"    is_built = true;",
"  }",
"",
"  int dfs_sz(int v) {",
"    int ret = 1, mx_sz = 0;",
"    for (Edge<int>& nxt : graph[v]) {",
"      if (nxt.to == parent[v]) continue;",
"",
"      parent[nxt.to] = v;",
"      depth[nxt.to] = depth[v] + 1;",
"      int sz = dfs_sz(nxt.to);",
"      ret += sz;",
"      if (mx_sz < sz) {",
"        mx_sz = sz;",
"        std::swap(graph[v][0], nxt);",
"      }",
"    }",
"",
"    return ret;",
"  }",
"",
"  void dfs_hld(int v, int& k) {",
"    id[v] = k; k++;",
"    for (Edge e : graph[v]) {",
"      if (e.to == parent[v]) continue;",
"",
"      // 今見ている辺が最大連結成分方向への辺なら,head[e.to] = head[v]",
"      // そうでないなら、head[e.to] = e.to;",
"      head[e.to] = (e == graph[v][0] ? head[v] : e.to);",
"      dfs_hld(e.to, k);",
"    }",
"    id2[v] = k;",
"  }",
"",
"  int lca(int u, int v) {",
"    assert(is_built);",
"    while (true) {",
"      if (id[u] > id[v]) std::swap(u, v);",
"      if (head[u] == head[v]) return u;",
"",
"      v = parent[head[v]];",
"    }",
"  }",
"",
"  Path get_path(int u, int v) {",
"    assert(is_built);",
"    Path upath, vpath;",
"",
"    while (head[u] != head[v]) {",
"",
"      // ちなみにu,vのdepthの大小関係は変わり続けることもある。",
"      // 10 → 12など。",
"",
"      // v's head is deeper",
"      if (depth[head[v]] >= depth[head[u]]) {",
"        assert(depth[head[v]] >= depth[head[u]]);",
"        /*",
"          /   : heavy edge",
"          .... : light edge",
"",
"            head[u]",
"                /",
"              /...",
"              u  ...",
"            /   head[v]",
"            /       |  ",
"          /         |  ",
"          /           v",
"        */",
"",
"        // u→v なのでreverse=false",
"        vpath.emplace_back(id[head[v]], id[v], false, false);",
"        v = parent[head[v]];",
"      }",
"",
"      // u's head is deeper",
"      else if (depth[head[v]] < depth[head[u]]) {",
"        /*",
"          /   : heavy edge",
"          .... : light edge",
"",
"            head[v]",
"                /",
"              /...",
"              v  ...",
"            /   head[u]",
"            /       |",
"          /         |",
"          /           u",
"        */",
"",
"        //",
"        upath.emplace_back(id[head[u]], id[u], false, true);",
"        u = parent[head[u]];",
"      }",
"    }",
"",
"    // v is deeper",
"    /*",
"        u",
"      /",
"      /  ←↓",
"    /",
"    v",
"",
"    */",
"    if (depth[v] > depth[u]) {",
"      upath.emplace_back(id[u], id[v], true, false);",
"    }",
"",
"    // u is deeper",
"    /*",
"        v",
"      /",
"      /  →↑",
"    /",
"    u",
"",
"    */",
"    else {",
"      upath.emplace_back(id[v], id[u], true, true);",
"    }",
"    Path retpath = upath;",
"    std::reverse(vpath.begin(), vpath.end());",
"    for (Interval path : vpath) retpath.push_back(path);",
"",
"    return retpath;",
"  }",
"",
"  std::pair<int,int> subtree_query(int r) {",
"    assert(r < int(id.size()));",
"    return std::make_pair(id[r], id2[r]);",
"  }",
"",
"};",
		],
		"description": "template for HLD_LCA_Eular_Tour"
	},
  "Moメモ" : {
		"prefix": "Mo_memo",
		"body": [
"ll bitlim = 0;",
"ll tmpn = n; // nは配列長の最大",
"while(tmpn > 0){",
"  bitlim++;",
"  tmpn>>= 1;",
"}",
"auto cp = [&](tpl3 a,tpl3 b)->bool{",
"  auto [al,ar,aid] = a;",
"  auto [bl,br,bid] = b;",
"  rrep(i,bitlim,0){",
"    if((ar >> i &1)^(br >> i & 1)){",
"      //0のほうを前に",
"      return (ar >> i & 1) == 0;",
"    }",
"    if((al >> i & 1)^(bl >> i & 1)){",
"      return (al >> i & 1) == 0;",
"    }",
"  }",
"  return false;",
"};",
"sort(all(lri),cp);",
"",
"",
"ll nl = 0,nr = 0;//半開区間",
"auto add =[&](ll i){",
"  ",
"};",
"",
"auto erase = [&](ll i){",
"",
"};",
"",
"auto clcans = [&](ll id)->mint {",
"  ",
"};",
"vector<mint> answer(q);",
"rep(i,q){",
"  auto [l,r,id] = lri[i];",
"  while(nr < r){",
"    add(nr++);",
"  }",
"  while(l < nl){",
"    add(--nl);",
"  }",
"  while(r < nr){",
"    erase(--nr);",
"  }",
"  while(nl < l){",
"    erase(nl++);",
"  }",
"  answer[id] = clcans(id);",
"}",

		],
		"description": "template for Mo"
	},
  "RangeSet" : {
		"prefix": "RangeSet_Mex",
		"body": [
"//ref https://atcoder.jp/contests/abc256/submissions/32647023",
"/*",
"verify",
"insert(l,r),printSet https://atcoder.jp/contests/adt_all_20250520_1/submissions/66027406",
"getRangeLength, insert(l,r) https://yukicoder.me/submissions/1087100",
"mex,insert(x) erase(x) https://atcoder.jp/contests/abc330/submissions/66027280",
"*/",
"template<class T>",
"struct RangeSet{",
"  set<pair<T,T>> se;",
"  T TINF;",
"",
"  RangeSet(T tinf):TINF{tinf}{ //TINFの値を定義する",
"    se.emplace(-TINF,-TINF);",
"    se.emplace(TINF,TINF);",
"  }",
"  T insert(T l,T r) {//半開区間",
"    auto itl = se.upper_bound({l,TINF}), itr = se.upper_bound({r,TINF});",
"    if (itl != se.begin() && (--itl)->second < l) itl++;",
"    T ret = T{0};",
"    T minus = T{0};",
"    if (itl != itr) {",
"        l = min(l , itl->first);",
"        r = max(r, prev(itr)->second);",
"        minus += itl->second - itl->first;",
"        minus += itr->second - itr->first;",
"        se.erase(itl,itr);",
"    }",
"    se.insert({l,r});",
"    ret += r-l;",
"    ret -= minus;",
"    return ret;",
"  }",
"",
"  T insert(T x){",
"    return insert(x,x+1);",
"  }",
"",
"  bool count(T x){",
"    auto it = prev(se.lower_bound({x+1,x+1}));",
"    return (it->first <= x && x < it->second);",
"  }",
"",
"  //ref https://mugen1337.github.io/procon/DataStructure/RangeSet.hpp",
"  //減少量(正の値)を返す",
"  T erase(T l,T r){ ",
"    assert(l<r);",
"    auto ite=prev(se.lower_bound({l+1,l+1}));",
"    if(ite->first<=l and r<=ite->second){",
"      // 完全に1つの区間に包含されている",
"      if(ite->first<l)  se.emplace(ite->first,l);",
"      if(r<ite->second) se.emplace(r,ite->second);",
"      se.erase(ite);",
"      return r-l;",
"    }",
"",
"    T ret=T(0);",
"    if(ite->first<=l and l<=ite->second){",
"      ret += ite->second -l;",
"      if(ite->first<l) se.emplace(ite->first,l);",
"      ite=se.erase(ite);// 次へ",
"    }else ite=next(ite);",
"",
"    while(ite->second<=r){",
"      ret += ite->second - ite->first;",
"      ite=se.erase(ite);",
"    }",
"    // 右端が区間の間にあるか",
"    if(ite->first<=r and r<ite->second){",
"      ret += r-ite->first;",
"      se.emplace(r,ite->second);",
"      se.erase(ite);",
"    }",
"    return ret;",
"  }",
"",
"  T erase(T x){",
"    return erase(x,x+1);",
"  }",
"  // number of range",
"  int size(){",
"    return (int)se.size()-2;",
"  }",
"  T getRangeLength(T x){",
"    auto it = prev(se.lower_bound({x+1,x+1}));",
"    if(it->first <= x && x < it->second){",
"      return it->second - it->first;",
"    }else{",
"      return T{0};",
"    }",
"  }",
"  vector<pair<T,T>> printSet(){",
"    vector<pair<T,T>>ret;",
"    for(const auto&[l,r]:se){",
"      if(l == -TINF || l == TINF)continue;",
"      ret.emplace_back(l,r);",
"    }",
"    return ret;",
"  }",
"",
"  T mex(T x = 0){",
"    auto [nowf,nows] = *prev(se.lower_bound({x+1,x+1}));",
"    if(nowf <=x  && x < nows){",
"      return nows;",
"    }else{",
"      return x;",
"    }",
"  }",
"};",

		],
		"description": "template for Range Set"
	},
  "convex_hull" : {
		"prefix": "TOTSUHOU_Convertex_hull",
		"body": [
"vector<pll> convex_hull(vpll p) { // 凸包",
"  auto cp_x =[](pll u,pll v){",
"    if(u.first != v.first){",
"      return u.first < v.first;",
"    }else{",
"      return u.second < v.second;",
"    }",
"  };",
"  sort(all(p), cp_x);",
"  p.erase(unique(all(p)), end(p));",
"  int n = sz(p), k = 0;",
"  if (n == 1) return p;",
"",
"  auto clc_vector = [](pll u,pll v) -> pll {",
"    return pll{u.first-v.first,u.second-v.second};",
"  };",
"",
"  auto det = [](pll u,pll v) -> ll {",
"    return u.first*v.second - u.second*v.first;",
"  };  ",
"",
"  vpll ch(2 * n);",
"  // 一直線上で高々2点 : det() <= 0",
"  // 一直線上で複数点(180度の角を許す) : det() < 0",
"  for (int i = 0; i < n; ch[k++] = p[i++]) {",
"      while (k >= 2 && det(clc_vector(ch[k - 1] ,ch[k - 2]), clc_vector(p[i],ch[k - 1])) <= 0)",
"          k--;",
"  }",
"  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {",
"      while (k >= t && det(clc_vector(ch[k - 1],ch[k - 2]),clc_vector(p[i],ch[k - 1])) <= 0)",
"          k--;",
"  }",
"  ch.resize(k - 1);",
"  return ch;",
"}",
		],
		"description": "template for 整数凸包"
	},
    "Zerobreak" : {
		"prefix": "Zerobreak",
		"body": [
"// for AOJ or ICPC or etc..",
"template<class Tp>",
"bool zero (const Tp &x) {",
"    return x == 0;",
"}",
"",
"template<class Tp, class... Args>",
"bool zero (const Tp &x, const Args& ...args) {",
"    return zero(x) and zero(args...);",
"}",
"",

		],
		"description": "template for Zerobreak "
	},
  "Dice" : {
		"prefix": "Dice_SAIKORO",
		"body": [
"//ref https://ei1333.github.io/library/other/dice.hpp",
"struct Dice {",
"  // int x, y;",
"  int  u, d, f, b, l, r;",
"  Dice(int uv,int dv,int fv,int bv,int lv,int rv){",
"    u= uv;d =dv;f =fv;b =bv;l=lv;r =rv;",
"  }",
"",
"  void RollN() {//  後ろから前に回転",
"    int buff = d;",
"    d = f;",
"    f = u;",
"    u = b;",
"    b = buff;",
"  }",
"",
"  void RollS() {// 前から後ろに回転",
"    int buff = d;",
"    d = b;",
"    b = u;",
"    u = f;",
"    f = buff;",
"  }",
"",
"  void RollL()  // -----> (側面回転)",
"  {",
"    int buff = f;",
"    f = l;",
"    l = b;",
"    b = r;",
"    r = buff;",
"  }",
"",
"  void RollR()  // <------ (側面回転)",
"  {",
"    int buff = f;",
"    f = r;",
"    r = b;",
"    b = l;",
"    l = buff;",
"  }",
"",
"  void RollE()  // .o -> o. (上面を左に落とす)",
"  {",
"    // --x;",
"    int buff = d;",
"    d = l;",
"    l = u;",
"    u = r;",
"    r = buff;",
"  }",
"",
"  void RollW()  // o. -> .o (上面を右に落とす)",
"  {",
"    //  ++x;",
"    int buff = d;",
"    d = r;",
"    r = u;",
"    u = l;",
"    l = buff;",
"  }",
"",
"  vector<Dice> makeDice() { // 何に使うのか不明",
"    vector<Dice> ret;",
"    for (int i = 0; i < 6; i++) {",
"      Dice d(*this);",
"      if (i == 1) d.RollN();",
"      if (i == 2) d.RollS();",
"      if (i == 3) d.RollS(), d.RollS();",
"      if (i == 4) d.RollL();",
"      if (i == 5) d.RollR();",
"      for (int j = 0; j < 4; j++) {",
"        ret.emplace_back(d);",
"        d.RollE();",
"      }",
"    }",
"    return (ret);",
"  }",
"};",
		],
		"description": "template for 6面ダイス"
	},
  "a" : {
		"prefix": "TEMPLATE",
		"body": [
	
		],
		"description": "template for "
	},
	
}
