{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	"atcoder-template": {
		"prefix": "atcoder",
		"body": [
			"#include <bits/stdc++.h>",
			"#include <atcoder/all>",
			"using namespace std;",
			"using namespace atcoder;",
			"#define rep(i, n) for (long long i = 0; i < (long long)(n); i++)",
			"#define rrep(i,start,end) for (long long i = start;i >= (long long)(end);i--)",
			"#define repn(i,end) for(long long i = 0; i <= (long long)(end); i++)",
			"#define reps(i,start,end) for(long long i = start; i < (long long)(end); i++)",
			"#define repsn(i,start,end) for(long long i = start; i <= (long long)(end); i++)",
			"#define each(p,a) for(auto &p:a)",
			"typedef long long ll;",
			"typedef unsigned long long ull;",
			"typedef long double ld;",
			"typedef vector<long long> vll;",
			"typedef vector<vector<long long>> vvll;",
			"typedef set<ll> sll;",
			"typedef map<long long , long long> mpll;",
			"typedef pair<long long ,long long> pll;",
			"typedef tuple<long long , long long , long long> tpl3;",
			"#define LL(...) ll __VA_ARGS__; input(__VA_ARGS__)",
			"#define LD(...) ld __VA_ARGS__; input(__VA_ARGS__)",
			"#define Str(...) string __VA_ARGS__; input(__VA_ARGS__)",
			"#define Ch(...) char __VA_ARGS__; input(__VA_ARGS__)",
			"#define all(a)  (a).begin(),(a).end()",
			"#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );",
			"// << std::fixed << std::setprecision(10)",
			"const ll INF = 1LL << 60;",
			" ",
			"inline ll positive_mod(ll a,ll m){return (a % m + m)%m;}",
			"inline ll popcnt(ull a){ return __builtin_popcountll(a);}",
			"template<class T> bool chmin(T& a, T b){if(a > b){a = b;return true;}return false;}",
			"template<class T> bool chmax(T& a, T b){if(a < b){a = b;return true;}return false;}",
			"template<class... T>void input(T&... a){(cin >> ... >> a);}",
			"//grid探索用",
			"vector<ll> _ta = {0,0,1,-1,1,1,-1,-1};",
			"vector<ll> _yo = {1,-1,0,0,1,-1,1,-1};",
			"bool isin(ll x,ll y,ll h,ll w){return (0<=x && x < h && 0 <= y && y < w);}",
			"  ",
			"ll lpow(ll x,ll n){ll ans = 1;while(n >0){if(n & 1)ans *= x;x *= x;n >>= 1;}return ans;}",
			"ll Modlpow(ll x,ll n,ll m){ll ans = 1;ll a = x;while(n >0){if(n & 1){ans *= a;ans%= m;}a *= a;a %= m;n >>= 1;}return ans;} ",
			"const ll MOD9 = 998244353LL;",
			"const ll MOD10 = 1000000007LL;",
			" ",
			"int main(){",
			"  ios::sync_with_stdio(false);cin.tie(nullptr);",
			"  ",
			"}"
			// "console.log('$1');",
			// "$2"
		],
		"description": "template for AtCoder"
	},
	"codeforces-template": {
		"prefix": "codeforces",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"#define rep(i, n) for (long long i = 0; i < (long long)(n); i++)",
			"#define rrep(i,start,end) for (long long i = start;i >= (long long)(end);i--)",
			"#define repn(i,end) for(long long i = 0; i <= (long long)(end); i++)",
			"#define reps(i,start,end) for(long long i = start; i < (long long)(end); i++)",
			"#define repsn(i,start,end) for(long long i = start; i <= (long long)(end); i++)",
			"#define each(p,a) for(auto &p:a)",
			"typedef long long ll;",
			"typedef unsigned long long ull;",
			"typedef long double ld;",
			"typedef vector<long long> vll;",
			"typedef vector<vector<long long>> vvll;",
			"typedef set<ll> sll;",
			"typedef map<long long , long long> mpll;",
			"typedef pair<long long ,long long> pll;",
			"typedef tuple<long long , long long , long long> tpl3;",
			"#define LL(...) ll __VA_ARGS__; input(__VA_ARGS__)",
			"#define LD(...) ld __VA_ARGS__; input(__VA_ARGS__)",
			"#define Str(...) string __VA_ARGS__; input(__VA_ARGS__)",
			"#define Ch(...) char __VA_ARGS__; input(__VA_ARGS__)",
			"#define all(a)  (a).begin(),(a).end()",
			"#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );",
			"// << std::fixed << std::setprecision(10)",
			"const ll INF = 1LL << 60;",
			" ",
			"inline ll positive_mod(ll a,ll m){return (a % m + m)%m;}",
			"inline ll popcnt(ull a){ return __builtin_popcountll(a);}",
			"template<class T> bool chmin(T& a, T b){if(a > b){a = b;return true;}return false;}",
			"template<class T> bool chmax(T& a, T b){if(a < b){a = b;return true;}return false;}",
			"template<class... T>void input(T&... a){(cin >> ... >> a);}",
			"//grid探索用",
			"vector<ll> _ta = {0,0,1,-1,1,1,-1,-1};",
			"vector<ll> _yo = {1,-1,0,0,1,-1,1,-1};",
			"bool isin(ll x,ll y,ll h,ll w){return (0<=x && x < h && 0 <= y && y < w);}",
			"  ",
			"ll lpow(ll x,ll n){ll ans = 1;while(n >0){if(n & 1)ans *= x;x *= x;n >>= 1;}return ans;}",
			"ll Modlpow(ll x,ll n,ll m){ll ans = 1;ll a = x;while(n >0){if(n & 1){ans *= a;ans%= m;}a *= a;a %= m;n >>= 1;}return ans;} ",
			"const ll MOD9 = 998244353LL;",
			"const ll MOD10 = 1000000007LL;",
			" ",
			"int main(){",
			"  ios::sync_with_stdio(false);cin.tie(nullptr);",
			"  ",
			"}"
			// "console.log('$1');",
			// "$2"
		],
		"description": "template for CodeForces"
	},
	"cout-endl;" : {
		"prefix": "co",
		"body": [
			"cout << $1 << endl;"
		],
		"description": "template for standard output"
	},
	"cout-space;" : {
		"prefix": "cou",
		"body": [
			"cout << $1 << \" \" ;"
		],
		"description": "template for standard output with space without endl"
	},
	"binary_search" : {
		"prefix": "Nibunntannsaku",
		"body": [
			"ll ng = $1;//条件を満たさない値",
			"ll ok = $2;//条件を満たす値",
			"auto f = [](ll mid)->bool{",
			" ",
			"};",
			"while(abs(ok-ng) > 1){",
			"  ll mid = (ok + ng)/2;",
			"  if(f(mid)){",
			"	   ok = mid;",
			"  }else{",
			"    ng = mid;",
			"  }",
			"}"

		],
		"description": "template for Binary search"
	},
	"素因数分解" : {
		"prefix": "Soinnsuubunnkai",
		"body": [
			"//素因数分解",
			"map<ll,ll> enumpr(ll n) {",
			"	map<ll,ll> V;",
			"	for(ll i=2;i*i<=n;i++) {",
			"    while(n%i==0){",
			"      V[i]++;",
			"      n/=i;",
			"    } ",
			"  }",
			"	if(n>1) V[n]++;",
			"	return V;",
			"}"
		],
		"description": "template for 素因数分解"
	},
	"約数列挙" : {
		"prefix": "Yakusuurekkyo",
		"body": [
			"//約数列挙",
			"vector<ll> divisor(ll n){",
			"  vector<ll> ret;",
			"  for(ll i = 1;i * i <= n;i++){",
			"    if(n % i == 0){",
			"      ret.push_back(i);",
			"      if(i * i != n)ret.push_back(n/i);",
			"    }",
			"  }",
			"  //昇順",
			"  sort(all(ret));",
			"  return ret;",
			"}"
		],
		"description": "template for 約数列挙"
	},
	"多倍長整数" : {
		"prefix": "Tabaityouseisuu",
		"body": [
			"#include <boost/multiprecision/cpp_int.hpp> ",
			"namespace bmp = boost::multiprecision;",
			"using Bint = bmp::cpp_int;"
		],
		"description": "template for 多倍長整数"
	},
	"時間計測" : {
		"prefix": "Jikannkeisoku",
		"body": [
			"std::chrono::system_clock::time_point  start, end; // 型は auto で可",
			"  start = std::chrono::system_clock::now(); // 計測開始時間",
			"  // 処理",
			"  end = std::chrono::system_clock::now();  // 計測終了時間",
			"  double elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(end-start).count(); //処理に要した時間をミリ秒に変換"
		],
		"description": "template for 時間計測"
	},
	"MaximumFlow" : {
		"prefix": "MaximumFlow",
		"body": [
			"struct Edge {",
			"	ll to,cap,rev;",
			"};",
			" ",
			"class MaximumFlow{",
			"	public:",
			"		ll siz = 0;",
			"		vector<bool> used;",
			"		vector<vector<Edge>> G;",
			"		MaximumFlow(ll n){",
			"			siz = n;",
			"			used.resize(n+1);",
			"			G.resize(n+1);",
			"		}",
			" ",
			"		// a からbにcリットル流せる辺を追加",
			"		void add_edge(ll a,ll b , ll c){",
			"			ll ga_size = G[a].size();",
			"			ll gb_size = G[b].size();",
			"			G[a].push_back({b,c,gb_size });",
			"			G[b].push_back({a,0,ga_size });",
			"		}",
			" ",
			"		//Fはスタートからposまでの残余グラフの辺の容量の最小値",
			"		//返り値は流したフローの量",
			"		ll dfs(ll pos,ll goal,ll F){",
			"			// ゴールに到着",
			"			if(pos == goal) return F;",
			" ",
			"			used[pos] = true;",
			" ",
			"			for(ll i = 0; i < (ll)G[pos].size();i++){",
			"				// 容量0の辺は使えない",
			"				if(G[pos][i].cap == 0)continue;",
			"				//探索済みだった",
			"				if(used[G[pos][i].to] ==  true) continue;",
			" ",
			"				ll flow = dfs(G[pos][i].to,goal,min(F,G[pos][i].cap));",
			" ",
			"				// フローを流せるとき、残余グラフの容量をflowだけ増減",
			"				if(flow > 0){",
			"					G[pos][i].cap -= flow;",
			"					G[G[pos][i].to][G[pos][i].rev].cap += flow;",
			"					return flow;",
			"				}",
			"			}",
			"			// 見つからず",
			"			return 0;",
			"		}",
			" ",
			"		ll max_flow(ll s,ll t){",
			"			ll Total_Flow = 0;",
			"			while(true){",
			"				for(ll i = 0;i < siz;i++)used[i] = false;",
			"					ll F = dfs(s,t,INF);",
			" ",
			"					//流せなくなった",
			"					if(F== 0)break;",
			"					Total_Flow += F;",
			"			}",
			"			return Total_Flow;",
			" ",
			"		}",
			"};"

		],
		"description": "template for Flow algorism"
	},
	"DFS" : {
		"prefix": "DFS",
		"body": [
			"vector<ll> found(n,0);//n頂点",
			"auto dfs = [&](auto dfs, ll v)->void{",
			"  found[v] = 1;",
			"  //gでグラフを受け取っている",
			"  for(auto &p:g[v]){",
			"    if(found[p] == 0){",
			"      dfs(dfs,p);",
			"    }",
			"  }",
			"};"
		],
		"description": "template for DFS"
	},
	"Warshall_floyd" : {
		"prefix": "WarshallFloyd",
		"body": [
			"/*隣接行列を更新してくDPのイメージ",
			"つながってない辺は重みINF、繋がってたら辺の重みで初期化",
			"O(V^3)",
			"*/",
			"int warshall_floyd(vector<vector<ll>> &dist){",
			"  int size = (int)dist.size();",
			"  rep(k,size){",
			"    rep(i,size){",
			"      rep(j,size){",
			"        if(i == j){",
			"          chmin(dist[i][j],0LL);",
			"        }",
			"        if(dist[i][k] != INF && dist[k][j] != INF){",
			"          chmin(dist[i][j],dist[i][k] + dist[k][j]);",
			"        }",
			"      }",
			"    }",
			"  }",
			"  //負の閉路判定あれば−1大丈夫なら1",
			"  rep(i,size){",
			"    if(dist[i][i]<0){",
			"      return -1;",
			"    }",
			"  }",
			"  return 1;",
			"}"
		],
		"description": "template for WarshallFloyd"
	},
	"TopologicalSort" : {
		"prefix": "DFS",
		"body": [
			"//隣接リストgを利用,n頂点",
			"auto topological_sort = [](vector<vector<ll>> &g,ll n){",
			"  vector<ll> topological_order;",
			" ",
			"  vector<ll> in_cnt(n);//入次数",
			"  rep(i,n){",
			"    for(ll p : g[i]){",
			"      in_cnt[p]++;",
			"    }",
			"  }",
			"  queue<ll> que;",
			"  //始点入れる",
			"  rep(i,n){",
			"    if(in_cnt[i] == 0){",
			"      que.push(i);",
			"    }",
			"  }",
			" ",
			"  while(!que.empty()){",
			"    ll now  = que.front();",
			"    que.pop();",
			"    topological_order.push_back(now);",
			"    for(ll p :g[now]){",
			"      if(in_cnt[p] > 0){",
			"        in_cnt[p]--;",
			"        if(in_cnt[p] == 0){",
			"          que.push(p);",
			"        }",
			"      }",
			"    }",
			"  }",
			"  return topological_order;",
			"};"
			
		],
		"description": "template for topologicalsort"
	},
	"Dijecstra" : {
		"prefix": "Daijecstra",
		"body": [
			"using P = pair<ll,ll>;",
			" ",
			"void Dijkstra(vector<ll> &dis,vector<vector<pair<ll,ll>>> &G,ll s){",
			"  // G[i]<j,d> i->j の距離(d)",
			"  // 「仮の最短距離, 頂点」が小さい順に並ぶ",
			"  priority_queue<P,vector<P>,greater<P>>pq;",
			"  dis[s] = 0;",
			"  pq.push({dis[s],s});",
			"  while(!pq.empty()){",
			"    auto [len,now] = pq.top();",
			"    pq.pop();",
			"    if(dis[now]< len){",
			"      continue;",
			"    }",
			"    for(auto &p:G[now]){",
			"      // 注意！",
			"      auto [next,cost] = p;",
			"      if(dis[next] > dis[now] + cost){",
			"        dis[next] = dis[now] + cost;",
			"        pq.push({dis[next],next});",
			"      }",
			"    }",
			"  }",
			"}"
		],
		"description": "template for Dijecstra"
	},
	"Kruskal" : {
		"prefix": "Kurasukaru",
		"body": [
			"/*",
			"小さい辺から見ていって２頂点が同じグループになければそのへんを追加する",
			"*/",
			" ",
			"ll kruskal(priority_queue<pair<ll,pair<ll,ll>>,vector<pair<ll,pair<ll,ll>>>,greater<pair<ll,pair<ll,ll>>>> pq,ll v){",
			"  dsu uf(v);",
			"  ll sum = 0;",
			"  while(!pq.empty()){",
			"    ll len = pq.top().first;",
			"    auto [a,b] = pq.top().second;",
			"    pq.pop();",
			"    if(!uf.same(a,b)){",
			"      sum += len;",
			"      uf.merge(a,b);",
			"    }",
			"  }",
			"  return sum;",
			"}"
		],
		"description": "template for Kruskal"
	},
	"UnionFind" : {
		"prefix": "UnionFind",
		"body": [
			"class UnionFind{",
			"  public:",
			"  vector<ll> par;",
			"  vector<ll> siz;",
			" ",
			"  UnionFind(ll n) {",
			"    par.resize(n,-1);",
			"    siz.resize(n,1);",
			"    _n = n;",
			"  }",
			" ",
			"  ll leader(ll a){",
			"    assert(0 <= a && a < _n);",
			"    while(par[a] != -1){",
			"      a = par[a];",
			"    }",
			"    return a;",
			"  }",
			" ",
			"  ll size(ll a){",
			"    assert(0 <= a && a < _n);",
			"    return size(siz[leader(a)]);",
			"  }",
			" ",
			"  ll merge(ll a,ll b){",
			"    assert(0 <= a && a < _n);",
			"    assert(0 <= b && b < _n);",
			"    ll u = leader(a);",
			"    ll v = leader(b);",
			"    if( u == v )return u;",
			"    if(siz[u] >= siz[v]){",
			"      par[v] = u;",
			"      siz[u] += siz[v];",
			"      return u;",
			"    }else{",
			"      par[u] = v;",
			"      siz[v] += siz[u];",
			"      return v;",
			"    }",
			"  }",
			" ",
			"  bool same(ll a,ll b){",
			"    assert(0 <= a && a < _n);",
			"    assert(0 <= b && b < _n);",
			"    if(leader(a) == leader(b)){",
			"      return true;",
			"    }else{",
			"      return false;",
			"    }",
			"  }",
			" ",
			"  vector<vector<ll>> groups(){",
			"    map<ll,vector<ll>> mp;",
			"    for(ll i = 0;i < _n;i++){",
			"      mp[leader(i)].push_back(i);",
			"    }",
			"    vector<vector<ll>> ans;",
			"    for(auto &p:mp){",
			"      vector<ll> now = p.second;",
			"      ans.push_back(now);",
			"    }",
			"    return ans;",
			"  }",
			" ",
			"  private:",
			"  ll _n;",
			"};"
		],
		"description": "template for UnionFind"
	},
	"SegmentTree" : {
		"prefix": "SegmentTree",
		"body": [
			"template <class T>",
			"class SegmentTree{",
			"  public:",
			"  vector<T> tree;",
			"  ll siz = 0;",
			"  T e; //単位元 初期化に使われるやつ",
			"  function<T(T,T)> op;",
			"  function<T(T,T)> mapping = [](T a,T b){return b;};//更新に使用 デフォルトはただ更新",
			" ",
			"  //とりあえず定義したい時用",
			"  SegmentTree():e(0),op([](T a,T b){return 0;}){",
			"    tree.resize(1 << 1,0);",
			"    siz = 1 << 0;",
			"  }",
			"  ",
			"  SegmentTree(ll n,T _e,function<T(T,T)> _op):e(_e),op(_op){",
			"    ll i = 0;",
			"    while((1 << i) < n ){",
			"      i++;",
			"    }",
			"    tree.resize(1<<(i+1),_e);",
			"    siz = 1 << i;",
			"  }",
			" ",
			"  //更新も工夫したいやつ",
			"  SegmentTree(ll n,T _e,function<T(T,T)> _op,function<T(T,T)>_mapping):e(_e),op(_op),mapping(_mapping){",
			"    ll i = 0;",
			"    while((1 << i) < n ){",
			"      i++;",
			"    }",
			"    tree.resize(1<<(i+1),_e);",
			"    siz = 1 << i;",
			"  }",
			"  ",
			"  void update(ll pos, T x){",
			"    pos = pos + siz-1;",
			"    tree[pos] = mapping(tree[pos],x);",
			"    while(pos >= 1){",
			"      pos = (pos-1)/2;",
			"      tree[pos] = op(tree[2 * pos +1], tree[2 * (pos+1)]);",
			"    }",
			"  }",
			" ",
			"  //[l,r) について、最初はa = 0,b = (SegmentTree).siz, p = 0 にしておく ",
			"  T _query(ll l, ll r, ll a, ll b, ll p){",
			"    if(r <= a or l >= b){",
			"      return e;",
			"    }",
			"    if(l <= a and b <= r){",
			"      return tree[p];",
			"    }",
			"    ll m = (a + b)/2;",
			"    T ansl = _query(l,r,a,m,2 * p+1);",
			"    T ansr = _query(l,r,m,b,2 * (p+1));",
			"    return op(ansl,ansr);",
			"  }",
			" ",
			"  //query呼び出し用[l,r)",
			"  T query(ll l,ll r){",
			"    return _query(l,r,0,siz,0);",
			"  }",
			" ",
			"  T operator[](ll pos){",
			"    return tree[pos + siz -1];",
			"  }",
			"  ",
			"};"
		],
		"description": "template for SegmentTree"
	},
	"SCC_graph" : {
		"prefix": "Scc_graph",
		"body": [
			"struct Scc_graph{",
			"  vector<vector<ll>> g;",
			"  ll _n;",
			" ",
			"  Scc_graph(ll n): _n(n){",
			"    g.resize(n);",
			"  }",
			" ",
			"  void add_edge(ll from,ll to){",
			"    assert(0 <= from && from < _n);",
			"    assert(0 <= to && to < _n);",
			"    g[from].push_back(to);",
			"  }",
			" ",
			"  vector<vector<ll>> scc(){",
			"    ll now_ord = 0,group_num = 0;//dfs行きかけで発見した頂点数、グループの数",
			"    vector<ll> visited;//発見したけどまだグループ分けされてない頂点",
			"    vector<ll> low(_n);//lowlink",
			"    vector<ll> ord(_n,-1);//order何番目に発見したか",
			"    vector<ll> ids(_n);//groupidが振られる",
			" ",
			"    auto dfs = [&](auto dfs,ll v)-> void{",
			"      ord[v] = now_ord;",
			"      low[v] = now_ord;",
			"      now_ord++;",
			"      visited.push_back(v);",
			"      for(auto &p:g[v]){",
			"        if(ord[p] == -1){",
			"          dfs(dfs,p);",
			"          low[v] = min(low[v],low[p]);",
			"        }else{",
			"          low[v] = min(low[v],ord[p]);//ord[p] == _nならグループに分けられてる",
			"        }",
			"      }",
			"      if(low[v] == ord[v]){",
			"        //scc_rootだった",
			"        while(true){",
			"          ll u = visited.back();",
			"          visited.pop_back();",
			"          ord[u] = _n;//グループに分けられた  ",
			"          ids[u] = group_num;",
			"          if(u == v)break;",
			"        }",
			"        group_num++;",
			"      } ",
			"    };",
			"    rep(i,_n){",
			"      if(ord[i] == -1){",
			"        dfs(dfs,i);",
			"      }",
			"    }",
			"    //group番号を逆順にする",
			"    for(auto &p:ids){",
			"      p = group_num - 1 - p;",
			"    }",
			"    vector<vector<ll>> groups(group_num);",
			"    rep(i,_n){",
			"      groups[ids[i]].push_back(i);",
			"    }",
			"    return groups;",
			"  }",
			" ",
			"};",
		],
		"description": "template for Scc_graph"
	},
	"RSQ" : {
		"prefix": "RSQ",
		"body": [
			"class RSQ{",
			"  public:",
			"  vector<ll> tree;",
			"  ll siz = 0;",
			"  RSQ(ll n){",
			"    ll i = 0;",
			"    while((1 << i) < n ){",
			"      i++;",
			"    }",
			"    tree.resize(1<<(i+1));",
			"    siz = 1 << i;",
			"  }",
			" ",
			"  void init(ll n){",
			"    ll i = 0;",
			"    while((1 << i) < n ){",
			"      i++;",
			"    }",
			"    tree.resize(1<<(i+1));",
			"    siz = 1 << i;",
			"  }",
			"  ",
			"  void update(ll pos, ll x){",
			"    pos = pos + siz-1;",
			"    tree[pos] = x;",
			"    while(pos >= 1){",
			"      pos = (pos-1)/2;",
			"      tree[pos] = tree[2 * pos +1]+tree[2 * (pos+1)];",
			"    }",
			"  }",
			"  //[l,r) について、最初はa = 0,b = (SegmentTree).siz, p = 0 にしておく",
			"  ll _query(ll l, ll r, ll a, ll b, ll p){",
			"    if(r <= a or l >= b){",
			"      return 0;",
			"    }",
			"    if(l <= a and b <= r){",
			"      return tree[p];",
			"    }",
			"    ll m = (a + b)/2;",
			"    ll ansl = _query(l,r,a,m,2 * p+1);",
			"    ll ansr = _query(l,r,m,b,2 * (p+1));",
			"    return ansl + ansr;",
			"  }",
			" ",
			"  ll query(ll l ,ll r){",
			"    return _query(l,r,0,siz,0);",
			"  }",
			" ",
			"  ll operator[](ll pos){",
			"    return tree[pos + siz -1];",
			"  }",
			"};"
		],
		"description": "template for RSQ"
	},
	"RMQ" : {
		"prefix": "RMQ",
		"body": [
			"class RMQ{",
			"  public:",
			"  vector<ll> tree;",
			"  ll siz = 0;",
			"  RMQ(ll n){",
			"    ll i = 0;",
			"    while((1 << i) < n ){",
			"      i++;",
			"    }",
			"    tree.resize(1<<(i+1));",
			"    siz = 1 << i;",
			"  }",
			" ",
			"  void init(ll n){",
			"    ll i = 0;",
			"    while((1 << i) < n ){",
			"      i++;",
			"    }",
			"    tree.resize(1<<(i+1));",
			"    siz = 1 << i;",
			"  }",
			"  ",
			"  void update(ll pos, ll x){",
			"    pos = pos + siz-1;",
			"    tree[pos] = x;",
			"    while(pos >= 1){",
			"      pos = (pos-1)/2;",
			"      tree[pos] = max(tree[2 * pos +1], tree[2 * (pos+1)]);",
			"    }",
			"  }",
			" ",
			"  //[l,r) について、最初はa = 0,b = (SegmentTree).siz, p = 0 にしておく ",
			"  ll _query(ll l, ll r, ll a, ll b, ll p){",
			"    if(r <= a or l >= b){",
			"      return -INF;",
			"    }",
			"    if(l <= a and b <= r){",
			"      return tree[p];",
			"    }",
			"    ll m = (a + b)/2;",
			"    ll ansl = _query(l,r,a,m,2 * p+1);",
			"    ll ansr = _query(l,r,m,b,2 * (p+1));",
			"    return max(ansl,ansr);",
			"  }",
			"  ",
			"  ll query(ll l ,ll r){",
			"    return _query(l,r,0,siz,0);",
			"  }",
			" ",
			"  ll operator[](ll pos){",
			"    return tree[pos + siz -1];",
			"  }",
			"};"
		],
		"description": "template for RMQ"
	},
	"RmQ" : {
		"prefix": "RmQ",
		"body": [
			"class SegmentTree{",
			"  public:",
			"  vector<ll> tree;",
			"  ll siz = 0;",
			"  SegmentTree(ll n){",
			"    ll i = 0;",
			"    while((1 << i) < n ){",
			"      i++;",
			"    }",
			"    tree.resize(1<<(i+1),INF);",
			"    siz = 1 << i;",
			"  }",
			" ",
			"  void init(ll n){",
			"    ll i = 0;",
			"    while((1 << i) < n ){",
			"      i++;",
			"    }",
			"    tree.resize(1<<(i+1),INF);",
			"    siz = 1 << i;",
			"  }",
			"  ",
			"  void update(ll pos, ll x){",
			"    pos = pos + siz-1;",
			"    tree[pos] = x;",
			"    while(pos >= 1){",
			"      pos = (pos-1)/2;",
			"      tree[pos] = min(tree[2 * pos +1], tree[2 * (pos+1)]);",
			"    }",
			"  }",
			" ",
			"  //[l,r) について、最初はa = 0,b = (SegmentTree).siz, p = 0 にしておく ",
			"  ll _query(ll l, ll r, ll a, ll b, ll p){",
			"    if(r <= a or l >= b){",
			"      return INF;",
			"    }",
			"    if(l <= a and b <= r){",
			"      return tree[p];",
			"    }",
			"    ll m = (a + b)/2;",
			"    ll ansl = _query(l,r,a,m,2 * p+1);",
			"    ll ansr = _query(l,r,m,b,2 * (p+1));",
			"    return min(ansl,ansr);",
			"  }",
			"  ",
			"  ll query(ll l ,ll r){",
			"    return _query(l,r,0,siz,0);",
			"  }",
			" ",
			"  ll operator[](ll pos){",
			"    return tree[pos + siz -1];",
			"  }",
			"};"
		],
		"description": "template for RmQ"
	},
	"nCk_strong" : {
		"prefix": "nCk_strong",
		"body": [
			"//最強,前処理(n), 計算(1)",
			"//n,k <= 10^7の時",
			"const ll MOD = 998244353;",
			"vector<long long> fact, fact_inv, inv;",
			"/*  init_nCk :二項係数のための前処理",
			"    計算量:O(n)",
			"*/",
			"void init_nCk(ll SIZE) {",
			"    fact.resize(SIZE + 5);",
			"    fact_inv.resize(SIZE + 5);",
			"    inv.resize(SIZE + 5);",
			"    fact[0] = fact[1] = 1;",
			"    fact_inv[0] = fact_inv[1] = 1;",
			"    inv[1] = 1;",
			"    for (int i = 2; i < SIZE + 5; i++) {",
			"        fact[i] = fact[i - 1] * i % MOD;",
			"        inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;//iの逆元",
			"        fact_inv[i] = fact_inv[i - 1] * inv[i] % MOD;//i!の逆元",
			"    }",
			"}",
			"/*  nCk :MODでの二項係数を求める(前処理 int_nCk が必要)",
			"    計算量:O(1)",
			"*/",
			"long long nCk(ll n, ll k) {",
			"    assert(!(n < k));",
			"    assert(!(n < 0 || k < 0));",
			"    return fact[n] * (fact_inv[k] * fact_inv[n - k] % MOD) % MOD;",
			"}"

		],
		"description": "template for nCk_strong"
	},
	"nCk_strong2" : {
		"prefix": "nCk_strong2",
		"body": [
			"/*",
			"k <= 10^7 n<= 10^9の時",
			"nが固定でない時",
			"*/",
			"ll MOD = 1e9+ 7;",
			"vector<ll> fact_inv,inv;",
			" ",
			"/*  init_nCk :二項係数のための前処理",
			"    計算量:O(k)",
			"*/",
			"void init_nCk(ll siz){",
			"	fact_inv.resize(siz + 5);",
			"	inv.resize(siz +5);",
			"	fact_inv[0] = 1;",
			"	fact_inv[1] = 1;",
			"	inv[1] = 1;",
			"	for(ll i = 2;i < siz +5;i++){",
			"		inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;",
			"		fact_inv[i] = fact_inv[i-1] * inv[i] % MOD;",
			"	}",
			"}",
			"/*  nCk :MODでの二項係数を求める(前処理 init_nCk が必要)",
			"    計算量:O(k)",
			"		n/1 * (n-1)/2 * ... *(n-k+1)/kを計算する",
			"*/",
			"ll nCk(ll n,ll k){",
			"	assert(!(n < k));",
			"  assert(!(n < 0 || k < 0));",
			"	ll ans = 1;",
			"	for(ll i = n;i >= n-k+1;i--){",
			"		ans *= i;",
			"		ans %= MOD;",
			"	}",
			"	return ans * fact_inv[k] % MOD;",
			"}"

		],
		"description": "template for nCk k <= 10^7 n<= 10^9の時,n固定でないとき"
	},
	"nCk_strong3" : {
		"prefix": "nCk_strong3",
		"body": [
			"/*",
			"k <= 10^7 n<= 10^9の時",
			"nが固定の時",
			"*/",
			"ll MOD = 1e9+ 7;",
			" ",
			"//fact_inv: i!の逆元",
			"//inv     : iの逆元",
			"//Com			: nCiの答え",
			"vector<ll> fact_inv,inv,Com;",
			" ",
			"/*  init_nCk :二項係数のための前処理",
			"    計算量:O(k)",
			"*/",
			"void init_nCk(ll n,ll siz){",
			"	fact_inv.resize(siz + 5);",
			"	inv.resize(siz +5);",
			"	fact_inv[0] = 1;",
			"	fact_inv[1] = 1;",
			"	inv[1] = 1;",
			"	for(ll i = 2;i < siz +5;i++){",
			"		inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;",
			"		fact_inv[i] = fact_inv[i-1] * inv[i] % MOD;",
			"	}",
			"	Com.resize(siz + 5);",
			"	Com[0] = 1;",
			"	//n/1 * (n-1)/2 * ... *(n-k+1)/kを計算する",
			"	for(ll i = 1;i < siz + 5;i++){",
			"		Com[i] = Com[i-1] *((n-i+1) *inv[i] % MOD)%MOD;",
			"	}",
			"}",
			"/*  nCk :MODでの二項係数を求める(前処理 init_nCk が必要)",
			"    計算量:O(1)",
			"*/",
			"ll nCk(ll k){",
			"	assert(!(k < 0));",
			"	return Com[k];",
			"}"
		],
		"description": "template for nCk k <= 10^7 n<= 10^9の時,n固定のとき"
	},
	"nCk_not_sosu" : {
		"prefix": "nCk_not_sosu",
		"body": [
			"/*",
			"MODが素数でない時も使える",
			"k,n <= 5000",
			"nCk = (n-1)C(k-1) + (n-1)Ckを利用したDP",
			"*/",
			"const int MAX_N = 5000;",
			"const long long MOD = 1000000007;",
			"long long Com[MAX_N][MAX_N];",
			"/* init_nCk:二項係数のための前処理",
			"    計算量:O(MAX_N*MAX_N)",
			"*/",
			"void init_nCk() {",
			"    memset(Com, 0, sizeof(Com));",
			"    Com[0][0] = 1;",
			"    for (int i = 1; i < MAX_N; ++i) {",
			"        Com[i][0] = 1;",
			"        for (int j = 1; j < MAX_N; j++) {",
			"            Com[i][j] = (Com[i - 1][j - 1] + Com[i - 1][j]) % MOD;",
			"        }",
			"    }",
			"}",
			"/*  nCk :MODでの二項係数を求める(前処理 int_nCk が必要)",
			"    計算量:O(1)",
			"*/",
			"long long nCk(int n, int k) {",
			"    assert(!(n < k));",
			"    assert(!(n < 0 || k < 0));",
			"    return Com[n][k];",
			"}"

		],
		"description": "template for nCk MODが素数でないときもOK、k,n <= 5000"
	},
	"nCk_not_MOD" : {
		"prefix": "nCk_not_MOD",
		"body": [
			"// Mod使わずllに収まる範囲でオーバーフローしないやつ",
			" ",
			"#define CMAX 1010",
			"ll noinit = 1; ll memo[CMAX][CMAX];",
			"ll nCr(ll a, ll b) {",
			"    if (noinit) {",
			"        rep(i, CMAX) rep(j, CMAX) memo[i][j] = -1;",
			"        noinit = 0;",
			"    }",
			"    if (b == 0 || a == b) return 1;",
			"    if (0 <= memo[a][b]) return memo[a][b];",
			"    return memo[a][b] = nCr(a - 1, b - 1) + nCr(a - 1, b);",
			"}"
		],
		"description": "template for nCk MOD取らなくてオーバーフローしないとき"
	},
	"Mint" : {
		"prefix": "Mint",
		"body": [
			"template<uint32_t m> class static_modint {",
			"    using mint = static_modint;",
			"    uint32_t _v = 0;",
			"    static constexpr bool prime = []() -> bool {",
			"        if (m == 1) return 0;",
			"        if (m == 2 || m == 7 || m == 61) return 1;",
			"        if (m % 2 == 0) return 0;",
			"        uint32_t d = m - 1;",
			"        while (d % 2 == 0) d /= 2;",
			"        for (uint32_t a : {2, 7, 61}) {",
			"            uint32_t t = d;",
			"            mint y = mint(a).pow(t);",
			"            while (t != m - 1 && y != 1 && y != m - 1) {",
			"                y *= y; t <<= 1;",
			"            }",
			"            if (y != m - 1 && t % 2 == 0) return 0;",
			"        }",
			"        return 1;",
			"    }();",
			"    static constexpr pair<int32_t, int32_t> inv_gcd(int32_t a, int32_t b) {",
			"        if (a == 0) return {b, 0};",
			"        int32_t s = b, t = a, m0 = 0, m1 = 1;",
			"        while (t) {",
			"            const int32_t u = s / t;",
			"            s -= t * u; m0 -= m1 * u;",
			"            swap(s, t); swap(m0, m1);",
			"        }",
			"        if (m0 < 0) m0 += b / s;",
			"        return {s, m0};",
			"    }",
			"public:",
			"    static constexpr mint raw(uint32_t v) { mint a; a._v = v; return a; }",
			"    constexpr static_modint() {}",
			"    template <class T>",
			"    constexpr static_modint(T v) {",
			"        static_assert(is_integral_v<T>, \"T is not integral type.\");",
			"        if constexpr (is_signed_v<T>) {",
			"            int64_t x = int64_t(v % int64_t(m));",
			"            if (x < 0) x += m; _v = uint32_t(x);",
			"        }",
			"        else _v = uint32_t(v % m);",
			"    }",
			"    static constexpr uint32_t mod() { return m; }",
			"    constexpr uint32_t val() const { return _v; }",
			"    constexpr mint& operator++() { return *this += 1; }",
			"    constexpr mint& operator--() { return *this -= 1; }",
			"    constexpr mint operator++(int) { mint res = *this; ++*this; return res; }",
			"    constexpr mint operator--(int) { mint res = *this; --*this; return res; }",
			"    constexpr mint& operator+=(mint rhs) {",
			"        if (_v >= m - rhs._v) _v -= m;",
			"        _v += rhs._v; return *this;",
			"    }",
			"    constexpr mint& operator-=(mint rhs) {",
			"        if (_v < rhs._v) _v += m;",
			"        _v -= rhs._v; return *this;",
			"    }",
			"    constexpr mint& operator*=(mint rhs) { return *this = *this * rhs; }",
			"    constexpr mint& operator/=(mint rhs) { return *this *= rhs.inv(); }",
			"    constexpr mint operator+() const { return *this; }",
			"    constexpr mint operator-() const { return mint{} - *this; }",
			"    constexpr mint pow(long long n) const {",
			"        assert(0 <= n);",
			"        if(n == 0) return 1;",
			"        mint x = *this, r = 1;",
			"        while (1) {",
			"            if (n & 1) r *= x; n >>= 1;",
			"            if (n == 0) return r;",
			"            x *= x;",
			"        }",
			"    }",
			"    constexpr mint inv() const {",
			"        if constexpr (prime) {",
			"            assert(_v);",
			"            return pow(m - 2);",
			"        } else {",
			"            auto eg = inv_gcd(_v, m);",
			"            assert(eg.first == 1);",
			"            return eg.second;",
			"        }",
			"    }",
			"    friend constexpr mint operator+(mint lhs, mint rhs) { return lhs += rhs; }",
			"    friend constexpr mint operator-(mint lhs, mint rhs) { return lhs -= rhs; }",
			"    friend constexpr mint operator*(mint lhs, mint rhs) { return uint64_t(lhs._v) * rhs._v; }",
			"    friend constexpr mint operator/(mint lhs, mint rhs) { return lhs /= rhs; }",
			"    friend constexpr bool operator==(mint lhs, mint rhs) { return lhs._v == rhs._v; }",
			"    friend constexpr bool operator!=(mint lhs, mint rhs) { return lhs._v != rhs._v; }",
			"};",
			"using modint998244353 = static_modint<998244353>;",
			"using modint1000000007 = static_modint<1000000007>;"

		],
		"description": "template for Mint"
	},
	"LCA" : {
		"prefix": "LCA",
		"body": [
			"using P = pair<ll,ll>;",
			" ",
			"template <class T>",
			"class SegmentTree{",
			"  public:",
			"  vector<T> tree;",
			"  ll siz = 0;",
			"  T e; //単位元 初期化に使われるやつ",
			"  function<T(T,T)> op;",
			"  function<T(T,T)> mapping = [](T a,T b){return b;};//更新に使用 デフォルトはただ更新",
			" ",
			"  //とりあえず定義したい時用",
			"  SegmentTree():e(0),op([](T a,T b){return 0;}){",
			"    tree.resize(1 << 1,0);",
			"    siz = 1 << 0;",
			"  }",
			"  ",
			"  SegmentTree(ll n,T _e,function<T(T,T)> _op):e(_e),op(_op){",
			"    ll i = 0;",
			"    while((1 << i) < n ){",
			"      i++;",
			"    }",
			"    tree.resize(1<<(i+1),_e);",
			"    siz = 1 << i;",
			"  }",
			" ",
			"  //更新も工夫したいやつ",
			"  SegmentTree(ll n,T _e,function<T(T,T)> _op,function<T(T,T)>_mapping):e(_e),op(_op),mapping(_mapping){",
			"    ll i = 0;",
			"    while((1 << i) < n ){",
			"      i++;",
			"    }",
			"    tree.resize(1<<(i+1),_e);",
			"    siz = 1 << i;",
			"  }",
			"  ",
			"  void update(ll pos, T x){",
			"    pos = pos + siz-1;",
			"    tree[pos] = mapping(tree[pos],x);",
			"    while(pos >= 1){",
			"      pos = (pos-1)/2;",
			"      tree[pos] = op(tree[2 * pos +1], tree[2 * (pos+1)]);",
			"    }",
			"  }",
			" ",
			"  //[l,r) について、最初はa = 0,b = (SegmentTree).siz, p = 0 にしておく ",
			"  T _query(ll l, ll r, ll a, ll b, ll p){",
			"    if(r <= a or l >= b){",
			"      return e;",
			"    }",
			"    if(l <= a and b <= r){",
			"      return tree[p];",
			"    }",
			"    ll m = (a + b)/2;",
			"    T ansr = _query(l,r,a,m,2 * p+1);",
			"    T ansl = _query(l,r,m,b,2 * (p+1));",
			"    return op(ansr,ansl);",
			"  }",
			" ",
			"  //query呼び出し用[l,r)",
			"  T query(ll l,ll r){",
			"    return _query(l,r,0,siz,0);",
			"  }",
			" ",
			"  T operator[](ll pos){",
			"    return tree[pos + siz -1];",
			"  }",
			"  ",
			"};",
			" ",
			"vector<pair<ll,ll>> euler_tour;//dfsしたときに現れる頂点の(深さ、頂点番号)",
			"vector<ll> first_appear;//頂点vがeulertour上で初めて現れるndex",
			" ",
			"//木をdfsしてeuler_tourとfirst_appearを埋める",
			"void dfs_euler(vector<vector<ll>> &g,ll v,vector<ll> &depth){",
			"  first_appear[v] = euler_tour.size();",
			"  euler_tour.push_back({depth[v],v});",
			"  for(auto &p:g[v]){",
			"    if(depth[p] == INF){",
			"      depth[p] = depth[v] + 1;",
			"      dfs_euler(g,p,depth);",
			"      euler_tour.push_back({depth[v],v});",
			"    }",
			"  }",
			"}",
			" ",
			"//euler_tourの情報をSeg木に乗せるだけ",
			"void seg_euler_setup(SegmentTree<P> &seg_euler){",
			"  ll siz = euler_tour.size();",
			"  rep(i,siz){",
			"    seg_euler.update(i,euler_tour[i]);",
			"  }",
			"}",
			" ",
			"// main関数内",
			" ",
			"/*",
			"  first_appear.resize(n,INF);",
			"  vector<ll> depth(n,INF);",
			"  //木の始点の距離を0にしておく",
			"  depth[0] = 0;",
			"  dfs_euler(g,0,depth);",
			"  SegmentTree<P> seg_euler((ll)euler_tour.size(),{INF,INF},[](P a,P b){return min(a,b) == a ? a : b;});",
			"  seg_euler_setup(seg_euler);",
			" ",
			"  // x,yのLCA求めるときは({深さ,頂点番号})",
			"  seg_euler.query(min(first_appear[x],first_appear[y]),max(first_appear[x],first_appear[y])+1);",
			" ",
			"*/"
		],
		"description": "template for LCA"
	},
	"Hash" : {
		"prefix": "Hash",
		"body": [
			"//global",
			"#define ulong unsigned long long",
			"const ulong MASK30 = (1UL << 30) - 1;",
			"const ulong MASK31 = (1UL << 31) - 1;",
			"const ulong MOD = (1UL << 61) - 1;",
			"const ulong MASK61 = MOD;",
			"const ulong POSITIVIZER = MOD * 4;",
			" ",
			"//mod 2^61-1を計算する関数",
			"ulong CalcMod(ulong x)",
			"{",
			"    ulong xu = x >> 61;",
			"    ulong xd = x & MASK61;",
			"    ulong res = xu + xd;",
			"    if (res >= MOD) res -= MOD;",
			"    return res;",
			"}",
			"//a*b mod 2^61-1を返す関数(最後にModを取る)",
			"ulong Mul(ulong a, ulong b)",
			"{",
			"    ulong au = a >> 31;",
			"    ulong ad = a & MASK31;",
			"    ulong bu = b >> 31;",
			"    ulong bd = b & MASK31;",
			"    ulong mid = ad * bu + au * bd;",
			"    ulong midu = mid >> 30;",
			"    ulong midd = mid & MASK30;",
			"    return CalcMod(au * bu * 2 + midu + (midd << 31) + ad * bd);",
			"}",
			" ",
			"//2^61 -1 で割る時のpow計算",
			" ",
			"ulong SuperMODpow(ll x,ll n){",
			"  // MOD = (1UL << 61) - 1;,Mul,CalcMod必要",
			"  ulong ans = 1;",
			"  ulong a = x;",
			"  while(n> 0){",
			"    if(n & 1){",
			"      ans = Mul(ans,a);",
			"    }",
			"    a = Mul(a,a);",
			"    n>>=1;",
			"  }",
			"  return ans;",
			"}",
			" ",
			" ",
			"/*",
			"  //main",
			"  vector<ll> hash(n+1,0);",
			"  //Hashの計算累積和的に,Hash[i] = [0,i)の半開で持つ",
			"  rep(i,n){",
			"    hash[i + 1] = CalcMod((Mul(hash[i],100LL) + (ll)(s[i] - 'A')));",
			"  }",
			" ",
			"  rep(i,q){",
			"    auto [a,b,c,d] = abcd[i];",
			"    ulong f = CalcMod(hash[b+1]+ POSITIVIZER - Mul(hash[a],SuperMODpow(100,b+1-a)));",
			"    ulong l = CalcMod(hash[d+1]+ POSITIVIZER - Mul(hash[c],SuperMODpow(100,d+1-c)));",
			"    // f,lはPOSITIVIZERを足したことで負にならない",
			"  }",
			"*/"

		],
		"description": "template for Hash"
	},
	"BFS" : {
		"prefix": "BFS",
		"body": [
			"queue<ll> que;",
			"//0からの距離が入る",
			"vector<ll> find(n,INF);",
			"find[0] = 0;",
			"que.push(0);",
			"while(!que.empty()){",
			"	ll now = que.front();",
			"	que.pop();",
			"	for(auto &p:g[now]){",
			"		if(find[p] == INF){",
			"			find[p] = find[now]+1;",
			"			que.push(p);",
			"		}",
			"	}",
			"}"

		],
		"description": "template for BFS"
	},
	"BellmanFord" : {
		"prefix": "Berumanford",
		"body": [
			"//負の閉検出、負の辺ありで単一始点最短経路",
			" ",
			"struct Edge{",
			"	ll from;",
			"	ll to;",
			"	ll cost;",
			"};",
			" ",
			"// 負の閉路が存在する場合 true を返し, 負閉路の影響を受ける頂点は -INF にセットされる",
			"// dist は頂点数と同じサイズ, 全要素 INF で初期化しておく",
			"// startからgoalの経路知りたいときは適宜変更",
			"bool BellmanFord(vector<Edge> &edges,vector<ll> &dist,ll start,ll goal = -1){",
			"	dist[start] = 0;",
			" ",
			"	vector<ll> parent(dist.size(),-1);",
			"	",
			"	rep(i,dist.size()){",
			"		bool changed = false;",
			"		for(auto &p:edges){",
			"			if(dist[p.from] == INF){",
			"				continue;",
			"			}",
			"			if(dist[p.from] + p.cost < dist[p.to]){",
			"				dist[p.to] = dist[p.from] + p.cost;",
			"				parent[p.to] = p.from;//直前の頂点を記憶",
			"				changed = true;",
			"			}",
			"		}",
			" ",
			"		//頂点の更新がなくなったら終了",
			"		if(changed == false){",
			"			return false;",
			"		}",
			"	}	",
			" ",
			"	//頂点数だけ更に繰り返して負の閉路を受ける点を-INFにしていく",
			"	rep(i,dist.size()){",
			"		for(auto &p:edges){",
			"			if(dist[p.from] == INF){",
			"				continue;",
			"			}",
			"			//まだ更新されるってことは負の閉路の影響をうけて無限に小さくなってしまう",
			"			if(dist[p.from] + p.cost < dist[p.to]){",
			"				dist[p.to] = -INF;",
			"			}",
			"		}",
			"	}",
			"	vector<ll> ret;",
			"	if(goal != -1 && dist[goal] != INF && dist[goal] != -INF){",
			"		for(ll i = goal;i != -1;i = parent[i]){",
			"			ret.push_back(i);",
			"		}",
			"	}",
			"	reverse(all(ret));",
			"	//必要ならretを出力してstartからgoalまでの経路を出力する",
			"	",
			"	",
			"	return true;",
			"}"

		],
		"description": "template for BellmanFord"
	},
	"LazySegmentTree" : {
		"prefix": "LazySegmentTree",
		"body": [
			"template<class X,class M>",
			"struct LazySegmentTree{",
			"	using FX = function<X(X,X)>;",
			"	using FA = function<X(X,M)>;",
			"	using FM = function<M(M,M)>;",
			"	using FP = function<M(M,ll)>;",
			"	ll siz;",
			"	FX fx; FA fa; FM fm; FP fp;",
			"	const X ex;//Xの単位元",
			"	const M em;//Mの単位元",
			"	vector<X> tree;",
			"	vector<M> lazy;",
			"	",
			"	LazySegmentTree(ll n,FX _fx,FA _fa,FM _fm,FP _fp,X _ex,M _em)",
			"	:fx(_fx),fa(_fa),fm(_fm),fp(_fp),ex(_ex),em(_em)",
			"	{",
			"		ll i = 0;",
			"		while((1 << i) < n){",
			"			i++;",
			"		}",
			"		tree.resize(1 << (i+1),_ex);",
			"		lazy.resize(1 << (i+1),_em);",
			"		siz = 1 << i;",
			"	}",
			"	//treeの初期値を入れる,posは0indexed",
			"	void set(ll pos, X x){",
			"		tree[pos  + siz -1] = x;",
			"	}",
			"	/*",
			"	siz = 4",
			"	tree:",
			"			0",
			"		1		2",
			"	 3 4 5 6",
			"	*/",
			"	//set()で入れた値でtreeを更新",
			"	void build(){",
			"		for(int i = siz -2;i >= 0;i--){",
			"			tree[i]  = fx(tree[2 * i+1],tree[2 * (i+1)]);",
			"		}",
			"	}",
			"	//遅延評価",
			"	void eval(ll p, ll len){",
			"		if(lazy[p] == em) return ;//更新するものがなければ終了",
			"		if(p < siz-1){",
			"			lazy[2*p+1] = fm(lazy[2*p+1],lazy[p]);",
			"			lazy[2*(p+1)] = fm(lazy[2*(p+1)],lazy[p]);",
			"		}",
			"		tree[p] = fa(tree[p],fp(lazy[p],len));//自身の更新",
			"		lazy[p] = em;",
			"	}",
			"",
			"	//やりたい区間[l,r),今見ている配列が対応する区間[a,b),今見ている配列の番地p",
			"	void _update(ll l, ll r, M x,ll a,ll b,ll p){",
			"		eval(p,b-a);//とりあえずまだ送ってないのがあれば下に伝搬",
			"		// lr <= ab or ab <= lr",
			"		if(r <= a || b <= l){",
			"			//範囲外だった",
			"			return ;",
			"		}",
			"		// l <= ab <= r",
			"		if(l <= a  && b <= r){",
			"			//完全に範囲内",
			"			lazy[p] = fm(lazy[p],x);",
			"			eval(p,b-a);",
			"			return ;",
			"		}",
			"		ll m = (a + b)/2;",
			"		_update(l,r,x,a,m,2 * p+1);",
			"		_update(l,r,x,m,b,2 * (p+1));",
			"		tree[p] = fx(tree[2*p+1],tree[2*(p+1)]);",
			"		",
			"	}",
			"	void update(ll l, ll r,M x){",
			"		_update(l,r,x,0,siz,0);",
			"	}",
			" ",
			"	X _query(ll l,ll r,ll a,ll b,ll p){",
			"		eval(p,b-a);//とりあえずまだ送ってないのを伝搬",
			"		// lr <= ab or ab <= lr",
			"		if(r <= a || b <= l){//範囲外",
			"			return ex;",
			"		}",
			"		// l <= ab <= r",
			"		if(l <= a && b <= r){//完全に範囲内",
			"			return tree[p];",
			"		}",
			"		ll m = (a + b)/2;",
			"		X ansl = _query(l,r,a,m,2 * p+1);",
			"		X ansr = _query(l,r,m,b,2 * (p+1));",
			"		return fx(ansl,ansr);",
			"		",
			"	}",
			" ",
			"	X query(ll l,ll r){",
			"		return _query(l,r,0,siz,0);",
			"	}",
			" ",
			"	X operator[](ll pos){",
			"    return tree[pos + siz -1];",
			"  }",
			" ",
			"};"
		],
		"description": "template for LazySegmentTree"
	},
	"テスト作成" : {
		"prefix": "Maketest",
		"body": [
			"//参照渡しで値を作成して渡す",
			"void Maketest(ll &n){",
			"//配列を渡すときは最初に.clear()をしておく",
			"	random_device seed_gen;",
			"  mt19937_64 rnd(seed_gen());",
			"  ",
			"  uniform_int_distribution<int> dist_N(1, 10);",
			"  n = dist_N(rnd);",
			"}"
		],
		"description": "template for test"
	},
	"拡張ユークリッドの互除法" : {
		"prefix": "kakutyouyu-kuriddo",
		"body": [
			"//返り値gcd(a,b)",
			"//ax + by = gcd(a,b)を満たすx,yを参照で返す",
			"ll extGCD(ll a,ll b,ll &x, ll&y){",
			"	if(b == 0){",
			"		x = 1;",
			"		y = 0;",
			"		return a;",
			"	}",
			"	ll d = extGCD(b,a % b,y,x);",
			"	y -= a/b * x;",
			"	return d;",
			"}"			
		],
		"description": "template for kakutyouyu-kuriddo"
	},
	"CRT" : {
		"prefix": "CRT",
		"body": [
			"//返り値gcd(a,b)",
			"//ax + by = gcd(a,b)を満たすx,yを参照で返す",
			"ll extGCD(ll a,ll b,ll &x, ll&y){",
			"	if(b == 0){",
			"		x = 1;",
			"		y = 0;",
			"		return a;",
			"	}",
			"	ll d = extGCD(b,a % b,y,x);",
			"	y -= a/b * x;",
			"	return d;",
			"}"
			" ",
			"// リターン値を (r, m) とすると解は x ≡ r (mod. m)",
			"// 解なしの場合は (0, -1) を返す",
			"// b:あまり、m:法",
			"pair<ll,ll> crt(const vector<ll> &b,const vector<ll> &m){",
			"	assert(b.size() == m.size());",
			"	ll r = 0; ll lcm_m = 1;",
			"	rep(i,b.size()){",
			"		ll p,q;",
			"		ll d = extGCD(lcm_m,m[i],p,q);",
			"		if((b[i] - r) % d != 0)return {0,-1};//解なし",
			"		ll tmp = (b[i]-r)/d * p % (m[i]/d);//多分オーバーフロー対策",
			"		r += lcm_m * tmp;",
			"		lcm_m *= m[i]/d;",
			"	}",
			"	return {(r % lcm_m+lcm_m)%lcm_m,lcm_m};",
			"}"
		],
		"description": "template for CRT"
	},
	"BIT" : {
		"prefix": "BIT",
		"body": [
			"template <class T>",
			"struct BIT{",
			"	ll siz;",
			"	vector<T> bit;",
			"	BIT(ll n){",
			"		siz = n+1;//1indexedで実装のため",
			"		bit.resize(n+1,0);",
			"	}",
			" ",
			"	/*",
			"				[       1,8        ]",
			"				[   1,4   ]",
			"				[1,2]     [5,6]",
			"				[1]  [3]  [5]  [7]",
			"		idx  1 2  3 4  5  6 7 8",
			"	*/",
			" ",
			"	//bit[p+1] += x",
			"	void add(ll p,T x){",
			"		p++;",
			"		for(ll i = p;i < siz;i += (i & -i)){",
			"			bit[i] += x;",
			"		}",
			"	}",
			" ",
			"	//bit[0] + bit[1] + ... + bit[p]を計算する",
			"	T sum(ll p){",
			"		T ret(0);",
			"		for(ll i = p;i >= 1; i-= (i & -i)){",
			"			ret += bit[i];",
			"		}",
			"		return ret;",
			"	}",
			" ",
			"	T operator [](ll pos){",
			"		return bit[pos+1];",
			"	}",
			" ",
			"};"
		],
		"description": "template for BIT"
	},
	
	
}
