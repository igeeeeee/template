//verify https://atcoder.jp/contests/abc289/submissions/70745629
// ax + bの最小値(上側凸包)
struct CHT_min{
  vpll lines;

  bool needchange(ll a,ll b){
    const auto&[a1,b1] = lines[lines.size()-1];
    const auto&[a0,b0] = lines[lines.size()-2];
    return (a0-a)*(b-b1) <= (a1-a)*(b-b0);//分母が両方正だから大丈夫
  }
  
  void add(ll a,ll b){
    if(!lines.empty() && lines.back().first == a){
      if(b >= lines.back().second)return ;//いらない
      lines.pop_back();
    }
    while((ll)lines.size() >= 2 && needchange(a,b)){
      lines.pop_back();
    }
    lines.emplace_back(a,b);
  }

  void build(vpll ab){
    auto cmp = [&](pll u,pll v){
      if(u.first != v.first){
        return u.first > v.first;
      }else{
        return u.second < v.second;//同じ傾きはb最小しか採用されない
      }
    };
    sort(all(ab),cmp);
    each(p,ab){
      add(p.first,p.second);
    }
  }

  ll get(ll x){//あるxでの値
    ll ok = lines.size()-1;//条件を満たす値
    ll ng = -1;//条件を満たさない値
    auto f = [&](ll mid)->bool {
      ll yi = lines[mid].first * x + lines[mid].second;
      ll yj = lines[mid+1].first * x + lines[mid+1].second;
      return yi <= yj;
    };
    while(abs(ok-ng) > 1){
      ll mid = (ok + ng)/2;
      if(f(mid)){
        ok = mid;
      }else{
        ng = mid;
      }
    }
    return lines[ok].first * x + lines[ok].second; 
  }
};

//verify https://atcoder.jp/contests/abc289/submissions/70745629
// ax + bの最大値(下側凸包)
struct CHT_max{
  vpll lines;

  bool needchange(ll a,ll b){
    const auto&[a1,b1] = lines[lines.size()-1];
    const auto&[a0,b0] = lines[lines.size()-2];
    return (a0-a)*(b-b1) <= (a1-a)*(b-b0);//分母が両方正だから大丈夫
  }
  
  void add(ll a,ll b){
    if(!lines.empty() && lines.back().first == a){
      if(b <= lines.back().second)return ;//いらない
      lines.pop_back();
    }
    while((ll)lines.size() >= 2 && needchange(a,b)){
      lines.pop_back();
    }
    lines.emplace_back(a,b);
  }

  void build(vpll ab){
    auto cmp = [&](pll u,pll v){
      if(u.first != v.first){
        return u.first < v.first;
      }else{
        return u.second > v.second;//同じ傾きはb最大しか採用されない
      }
    };
    sort(all(ab),cmp);
    each(p,ab){
      add(p.first,p.second);
    }
  }

  ll get(ll x){//あるxでの値
    ll ok = lines.size()-1;//条件を満たす値
    ll ng = -1;//条件を満たさない値
    auto f = [&](ll mid)->bool {
      ll yi = lines[mid].first * x + lines[mid].second;
      ll yj = lines[mid+1].first * x + lines[mid+1].second;
      return yi >= yj;
    };
    while(abs(ok-ng) > 1){
      ll mid = (ok + ng)/2;
      if(f(mid)){
        ok = mid;
      }else{
        ng = mid;
      }
    }
    return lines[ok].first * x + lines[ok].second; 
  }
};