//ref https://algo-logic.info/trie-tree/#
// verify https://atcoder.jp/contests/abc353/submissions/72315421
//i番目のノードのrootからの距離がもしかしたら怪しいかも
//char_size:文字の種類数、その0番目に当たる文字を base
//例 : Trie<26,'a'>
template<ll char_size,ll base>
struct Trie{
  struct Node{
    vector<ll> nxt;//子のidx,存在しないなら-1
    vector<ll> accept;//その頂点が末端となる文字列のid
    ll d; //baseからの距離
    ll common; //その頂点を何個の文字列が共有しているか
    Node(ll _d){
      d = _d;
      common = 0;
      nxt.assign(char_size,-1);
    }
  };

  vector<Node> nodes;
  ll root;

  Trie(){
    root = 0;
    nodes.push_back(Node(root));
  }

  //文字列の挿入
  ll insert(const string &s,ll wordid){
    ll v = 0;
    rep(i,s.size()){
      ll c = (ll)(s[i] - base);
      ll nv = nodes[v].nxt[c];
      if(nv == -1){//次の頂点がない
        nv = nodes.size();
        nodes.push_back(Node(nodes[v].d + 1)); //rootからの距離をNodeに持たせる.参考元から変更した
        nodes[v].nxt[c] = nv;
      }
      nodes[v].common++;
      v = nv;
    }
    nodes[v].common++;
    nodes[v].accept.push_back(wordid);
    return v;
  }
  ll insert(const string &s){
    return insert(s,nodes[0].common);
  }

  //wordがすでに存在するか
  bool search(const string &s,bool prefix = false){
    ll v = 0;
    rep(i,s.size()){
      ll c = (ll)(s[i] - base);
      ll nv = nodes[v].nxt[c];
      if(nv == -1){//次の頂点がない
        return false;
      }
      v = nv;
    }
    if(prefix){
      return true;
    }else{
      return nodes[v].accept.size() > 0;
    }
  }
  bool start_with(const string &prefix){
    return search(prefix,true);
  }

  //挿入した数
  ll count() const {
    return nodes[0].common;
  }

  // Trie木のノードの数
  ll size() const {
    return nodes.size();
  }
};