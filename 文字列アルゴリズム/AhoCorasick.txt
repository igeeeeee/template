/**
 * @struct AhoCorasick
 * @brief 文字列(text)と文字列集合(words)があるときにtext内に各wordがいくつ現れるかの計算
 * 
 * @details
 * Trie木を普通に構築(insert)した後、BFSでfailの計算(set_fail)
 * set_fail()ではTrie木上の各nodeがが末尾となるwordの集合がacceptになるように更新
 * 
 * @note 
 * fail : 今見ている文字列の接尾辞でTie木上に登録されているキーワードの接頭辞のうち最長のもの
 * 
 * @complexity
 * 構築 O(Σ|words[i]|) wordsの文字列長の合計
 * 検索 O(|text| + 出現数)
 * 
 * @ref
 * https://kntychance.hatenablog.jp/entry/2024/07/28/144203#fail-%E3%81%AE%E5%89%8D%E8%A8%88%E7%AE%97
 * https://ei1333.github.io/luzhiled/snippets/string/aho-corasick.html
 * 
 * @vefify
 * https://atcoder.jp/contests/abc362/submissions/68592335
 */
template<int char_size,int base>
struct AhoCorasick {
  struct Node{
    vector<int> next;//子のidx,存在しないなら-1
    vector<int> accept;//その頂点が末端となる文字列のid
    int c; //baseからの距離
    int common; //その頂点を何個の文字列が共有しているか
    Node(int _c){
      c = _c;
      common = 0;
      next.assign(char_size+1,-1);//next[char_size]はfailの行き先
    }
  };

  vector<Node> nodes;
  int root;
  int fail = char_size;
  int words_size;//何個の文字列を登録したか

  AhoCorasick(vector<string> &words){
    root = 0;
    words_size = (int)words.size();
    nodes.push_back(Node(root));
    for(const auto &word:words){ // Trie木上にwords内の文字列を配置
      insert(word);
    }
    set_fail();
  }

  void insert(const string &word,int wordid){
    int nodeid = 0;
    rep(i,word.size()){
      int c = (int)(word[i] - base);
      int nextid = nodes[nodeid].next[c];
      if(nextid == -1){//次の頂点がない
        nextid = nodes.size();
        nodes.push_back(Node(nodes[nodeid].c + 1)); //rootからの距離をNodeに持たせる.参考元から変更した
        nodes[nodeid].next[c] = nextid;
      }
      nodes[nodeid].common++;
      nodeid = nextid;
    }
    nodes[nodeid].common++;
    nodes[nodeid].accept.push_back(wordid);
  }
  void insert(const string &word){
    insert(word,nodes[0].common);
  }

  void set_fail(){
    queue<int> que;
    //rootの処理
    for(int i = 0;i < char_size;++i){
      if(nodes[root].next[i]!= -1){
        nodes[nodes[root].next[i]].next[fail] = root;
        que.push(nodes[root].next[i]);
      }else{
        nodes[root].next[i] = 0;
      }
    }
    nodes[root].next[fail] = root;
    while(!que.empty()){
      ll now = que.front();
      que.pop();
      //childsのfailを計算
      for(int i = 0;i < char_size;++i)if(nodes[now].next[i] != -1){
        int nid = nodes[now].next[fail];
        while(nodes[nid].next[i]== -1){
          nid = nodes[nid].next[fail];
        }
        nodes[nodes[now].next[i]].next[fail] = nodes[nid].next[i];
        que.push(nodes[now].next[i]);
        //acceptの追加
        vector<int> naccept;
        auto &u = nodes[nodes[now].next[i]].accept;
        auto &v = nodes[nodes[nid].next[i]].accept; 
        set_union(u.begin(),u.end(),v.begin(),v.end(),back_inserter(naccept));
        nodes[nodes[now].next[i]].accept = naccept;
      }
    }
  }
  
  //text内に各文字列がそれぞれ何回現れるか
  vector<ll> count(string& text){
    vector<int> visited_cnt(nodes.size());//各nodeを何回訪れたか
    int id = 0;
    for(const char &p:text){
      int c = (int)(p - base);
      if(nodes[id].next[c] != -1){
        id = nodes[id].next[c];
        visited_cnt[id]++;
      }else{
        while(nodes[nodes[id].next[fail]].next[c] == -1){
          id = nodes[id].next[fail];
        }
        id = nodes[nodes[id].next[fail]].next[c];
        visited_cnt[id]++;
      }
    }
    vector<ll> ret(words_size);
    for(int i = 0;i < (int)nodes.size();++i){
      for(auto &p:nodes[i].accept){
        ret[p] += (ll)visited_cnt[i];
      }
    }
    return ret;
  }
};